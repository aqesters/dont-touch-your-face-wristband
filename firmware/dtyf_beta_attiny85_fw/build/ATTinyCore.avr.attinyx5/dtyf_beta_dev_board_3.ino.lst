
/private/var/folders/29/kllrrlc97vqc5shptfvqt_yr0000gn/T/arduino/sketches/C3891286C932CD308431EFC06A9EF736/dtyf_beta_dev_board_3.ino.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
__vectors():
   0:	1e c0       	rjmp	.+60     	; 0x3e <__ctors_end>
   2:	37 c0       	rjmp	.+110    	; 0x72 <__bad_interrupt>
   4:	9c c4       	rjmp	.+2360   	; 0x93e <__vector_2>
   6:	35 c0       	rjmp	.+106    	; 0x72 <__bad_interrupt>
   8:	34 c0       	rjmp	.+104    	; 0x72 <__bad_interrupt>
   a:	33 c0       	rjmp	.+102    	; 0x72 <__bad_interrupt>
   c:	32 c0       	rjmp	.+100    	; 0x72 <__bad_interrupt>
   e:	31 c0       	rjmp	.+98     	; 0x72 <__bad_interrupt>
  10:	30 c0       	rjmp	.+96     	; 0x72 <__bad_interrupt>
  12:	2f c0       	rjmp	.+94     	; 0x72 <__bad_interrupt>
  14:	2e c0       	rjmp	.+92     	; 0x72 <__bad_interrupt>
  16:	2d c0       	rjmp	.+90     	; 0x72 <__bad_interrupt>
  18:	83 c4       	rjmp	.+2310   	; 0x920 <__vector_12>
  1a:	69 c4       	rjmp	.+2258   	; 0x8ee <__vector_13>
  1c:	ee c3       	rjmp	.+2012   	; 0x7fa <__vector_14>

0000001e <__trampolines_end>:
__trampolines_start():
  1e:	00 00       	nop
  20:	00 00       	nop
  22:	37 00       	.word	0x0037	; ????

00000024 <port_to_output_PGM>:
  24:	00 00 00 00 38 00                                   ....8.

0000002a <digital_pin_to_timer_PGM>:
  2a:	01 03 00 00 04 00                                   ......

00000030 <digital_pin_to_port_PGM>:
  30:	02 02 02 02 02 02                                   ......

00000036 <digital_pin_to_bit_mask_PGM>:
  36:	01 02 04 08 10 20                                   ..... 

0000003c <__ctors_start>:
__ctors_start():
  3c:	fa 05       	cpc	r31, r10

0000003e <__ctors_end>:
__dtors_end():
  3e:	11 24       	eor	r1, r1
  40:	1f be       	out	0x3f, r1	; 63
  42:	cf e5       	ldi	r28, 0x5F	; 95
  44:	d2 e0       	ldi	r29, 0x02	; 2
  46:	de bf       	out	0x3e, r29	; 62
  48:	cd bf       	out	0x3d, r28	; 61

0000004a <__do_clear_bss>:
__do_clear_bss():
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2441
  4a:	20 e0       	ldi	r18, 0x00	; 0
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2442
  4c:	a0 e6       	ldi	r26, 0x60	; 96
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2443
  4e:	b0 e0       	ldi	r27, 0x00	; 0
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2444
  50:	01 c0       	rjmp	.+2      	; 0x54 <.do_clear_bss_start>

00000052 <.do_clear_bss_loop>:
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2446
  52:	1d 92       	st	X+, r1

00000054 <.do_clear_bss_start>:
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2448
  54:	a5 3a       	cpi	r26, 0xA5	; 165
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2449
  56:	b2 07       	cpc	r27, r18
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2450
  58:	e1 f7       	brne	.-8      	; 0x52 <.do_clear_bss_loop>

0000005a <__do_global_ctors>:
__do_global_ctors():
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2466
  5a:	10 e0       	ldi	r17, 0x00	; 0
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2467
  5c:	cf e1       	ldi	r28, 0x1F	; 31
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2468
  5e:	d0 e0       	ldi	r29, 0x00	; 0
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2472
  60:	03 c0       	rjmp	.+6      	; 0x68 <__do_global_ctors+0xe>
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2474
  62:	21 97       	sbiw	r28, 0x01	; 1
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2480
  64:	fe 01       	movw	r30, r28
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2481
  66:	ba d7       	rcall	.+3956   	; 0xfdc <__tablejump2__>
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2483
  68:	ce 31       	cpi	r28, 0x1E	; 30
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2484
  6a:	d1 07       	cpc	r29, r17
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2489
  6c:	d1 f7       	brne	.-12     	; 0x62 <__do_global_ctors+0x8>
  6e:	76 d4       	rcall	.+2284   	; 0x95c <main>
  70:	bb c7       	rjmp	.+3958   	; 0xfe8 <_exit>

00000072 <__bad_interrupt>:
__vector_1():
  72:	c6 cf       	rjmp	.-116    	; 0x0 <__vectors>

00000074 <TwoWire::write(unsigned char) [clone .constprop.39]>:
_ZN7TwoWire5writeEh.constprop.39():
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/Wire.cpp:507

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(uint8_t data) {
  if (transmitting) { // in master transmitter mode
  74:	90 91 a2 00 	lds	r25, 0x00A2	; 0x8000a2 <TwoWire::transmitting>
  78:	99 23       	and	r25, r25
  7a:	a1 f0       	breq	.+40     	; 0xa4 <TwoWire::write(unsigned char) [clone .constprop.39]+0x30>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/Wire.cpp:509
    // don't bother if buffer is full
    if (BufferLength >= TWI_BUFFER_SIZE) {
  7c:	90 91 a4 00 	lds	r25, 0x00A4	; 0x8000a4 <TwoWire::BufferLength>
  80:	90 32       	cpi	r25, 0x20	; 32
  82:	40 f5       	brcc	.+80     	; 0xd4 <TwoWire::write(unsigned char) [clone .constprop.39]+0x60>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/Wire.cpp:513
      return 0;
    }
    // put byte in tx buffer
    Buffer[BufferIndex] = data;
  84:	90 91 a3 00 	lds	r25, 0x00A3	; 0x8000a3 <TwoWire::BufferIndex>
  88:	e9 2f       	mov	r30, r25
  8a:	f0 e0       	ldi	r31, 0x00	; 0
  8c:	e0 5a       	subi	r30, 0xA0	; 160
  8e:	ff 4f       	sbci	r31, 0xFF	; 255
  90:	80 83       	st	Z, r24
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/Wire.cpp:514
    ++BufferIndex;
  92:	81 e0       	ldi	r24, 0x01	; 1
  94:	89 0f       	add	r24, r25
  96:	80 93 a3 00 	sts	0x00A3, r24	; 0x8000a3 <TwoWire::BufferIndex>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/Wire.cpp:516
    // update amount in buffer
    BufferLength = BufferIndex;
  9a:	80 93 a4 00 	sts	0x00A4, r24	; 0x8000a4 <TwoWire::BufferLength>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/Wire.cpp:525
      return 0;
    }
    // reply to master
    USI_TWI_Transmit_Byte(data);
  }
  return 1;
  9e:	81 e0       	ldi	r24, 0x01	; 1
  a0:	90 e0       	ldi	r25, 0x00	; 0
  a2:	08 95       	ret
USI_TWI_Space_In_Transmission_Buffer():
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Slave/USI_TWI_Slave.c:144

// Check if there is space in the transmission buffer.
unsigned char USI_TWI_Space_In_Transmission_Buffer(void)
{
  unsigned char tmpTxHead;
  tmpTxHead = (TWI_TxHead + 1) & TWI_TX_BUFFER_MASK; // Calculate next buffer index.
  a4:	20 91 a0 00 	lds	r18, 0x00A0	; 0x8000a0 <TWI_TxHead>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Slave/USI_TWI_Slave.c:145
  return (TWI_TxTail - tmpTxHead) & TWI_TX_BUFFER_MASK; // Return 0 (FALSE) if the transmission buffer is full.
  a8:	90 91 9f 00 	lds	r25, 0x009F	; 0x80009f <TWI_TxTail>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Slave/USI_TWI_Slave.c:144

// Check if there is space in the transmission buffer.
unsigned char USI_TWI_Space_In_Transmission_Buffer(void)
{
  unsigned char tmpTxHead;
  tmpTxHead = (TWI_TxHead + 1) & TWI_TX_BUFFER_MASK; // Calculate next buffer index.
  ac:	2f 5f       	subi	r18, 0xFF	; 255
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Slave/USI_TWI_Slave.c:145
  return (TWI_TxTail - tmpTxHead) & TWI_TX_BUFFER_MASK; // Return 0 (FALSE) if the transmission buffer is full.
  ae:	92 1b       	sub	r25, r18
  b0:	9f 70       	andi	r25, 0x0F	; 15
_ZN7TwoWire5writeEh.constprop.39():
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/Wire.cpp:519
    ++BufferIndex;
    // update amount in buffer
    BufferLength = BufferIndex;
  } else { // in slave send mode
    // don't bother if buffer is full
    if (!USI_TWI_Space_In_Transmission_Buffer()) {
  b2:	81 f0       	breq	.+32     	; 0xd4 <TwoWire::write(unsigned char) [clone .constprop.39]+0x60>
USI_TWI_Transmit_Byte():
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Slave/USI_TWI_Slave.c:100
// Puts data in the transmission buffer, Waits if buffer is full.
void USI_TWI_Transmit_Byte(unsigned char data)
{
  unsigned char tmphead;

  tmphead = (TWI_TxHead + 1) & TWI_TX_BUFFER_MASK; // Calculate buffer index.
  b4:	90 91 a0 00 	lds	r25, 0x00A0	; 0x8000a0 <TWI_TxHead>
  b8:	9f 5f       	subi	r25, 0xFF	; 255
  ba:	9f 70       	andi	r25, 0x0F	; 15
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Slave/USI_TWI_Slave.c:101
  while (tmphead == TWI_TxTail)
  bc:	20 91 9f 00 	lds	r18, 0x009F	; 0x80009f <TWI_TxTail>
  c0:	92 17       	cp	r25, r18
  c2:	e1 f3       	breq	.-8      	; 0xbc <TwoWire::write(unsigned char) [clone .constprop.39]+0x48>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Slave/USI_TWI_Slave.c:103
    ;                         // Wait for free space in buffer.
  TWI_TxBuf[tmphead] = data;    // Store data in buffer.
  c4:	e9 2f       	mov	r30, r25
  c6:	f0 e0       	ldi	r31, 0x00	; 0
  c8:	e0 59       	subi	r30, 0x90	; 144
  ca:	ff 4f       	sbci	r31, 0xFF	; 255
  cc:	80 83       	st	Z, r24
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Slave/USI_TWI_Slave.c:104
  TWI_TxHead         = tmphead; // Store new index.
  ce:	90 93 a0 00 	sts	0x00A0, r25	; 0x8000a0 <TWI_TxHead>
  d2:	e5 cf       	rjmp	.-54     	; 0x9e <TwoWire::write(unsigned char) [clone .constprop.39]+0x2a>
_ZN7TwoWire5writeEh.constprop.39():
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/Wire.cpp:510
// or after beginTransmission(address)
size_t TwoWire::write(uint8_t data) {
  if (transmitting) { // in master transmitter mode
    // don't bother if buffer is full
    if (BufferLength >= TWI_BUFFER_SIZE) {
      return 0;
  d4:	90 e0       	ldi	r25, 0x00	; 0
  d6:	80 e0       	ldi	r24, 0x00	; 0
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/Wire.cpp:526
    }
    // reply to master
    USI_TWI_Transmit_Byte(data);
  }
  return 1;
}
  d8:	08 95       	ret

000000da <TwoWire::beginTransmission(unsigned char) [clone .constprop.38]>:
_ZN7TwoWire17beginTransmissionEh.constprop.38():
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/Wire.cpp:462
  return requestFrom((uint8_t)address, (uint8_t)quantity, (uint8_t)sendStop);
}

void TwoWire::beginTransmission(uint8_t address) {
  // indicate that we are transmitting
  transmitting = 1;
  da:	91 e0       	ldi	r25, 0x01	; 1
  dc:	90 93 a2 00 	sts	0x00A2, r25	; 0x8000a2 <TwoWire::transmitting>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/Wire.cpp:464
  // set address of targeted slave and write mode
  Buffer[0] = (address << TWI_ADR_BITS) | (0 << TWI_READ_BIT);
  e0:	88 0f       	add	r24, r24
  e2:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/Wire.cpp:466
  // reset tx buffer iterator vars
  BufferIndex = 1; // reserved by slave address
  e6:	90 93 a3 00 	sts	0x00A3, r25	; 0x8000a3 <TwoWire::BufferIndex>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/Wire.cpp:467
  BufferLength = BufferIndex;
  ea:	90 93 a4 00 	sts	0x00A4, r25	; 0x8000a4 <TwoWire::BufferLength>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/Wire.cpp:468
}
  ee:	08 95       	ret

000000f0 <TwoWire::read() [clone .constprop.32]>:
_ZN7TwoWire4readEv.constprop.32():
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/Wire.cpp:551

// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::available(void) {
  if (BufferLength) {
  f0:	80 91 a4 00 	lds	r24, 0x00A4	; 0x8000a4 <TwoWire::BufferLength>
  f4:	88 23       	and	r24, r24
  f6:	39 f0       	breq	.+14     	; 0x106 <TwoWire::read() [clone .constprop.32]+0x16>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/Wire.cpp:552
    return BufferLength - BufferIndex;
  f8:	20 91 a3 00 	lds	r18, 0x00A3	; 0x8000a3 <TwoWire::BufferIndex>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/Wire.cpp:565
// or after requestFrom(address, numBytes)
int TwoWire::read(void) {
  int value = -1;

  // get each successive byte on each call
  if (available()) {
  fc:	82 13       	cpse	r24, r18
  fe:	1c c0       	rjmp	.+56     	; 0x138 <TwoWire::read() [clone .constprop.32]+0x48>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/Wire.cpp:562

// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::read(void) {
  int value = -1;
 100:	8f ef       	ldi	r24, 0xFF	; 255
 102:	9f ef       	ldi	r25, 0xFF	; 255
 104:	08 95       	ret
USI_TWI_Data_In_Receive_Buffer():
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Slave/USI_TWI_Slave.c:136

// Check if there is data in the receive buffer.
unsigned char USI_TWI_Data_In_Receive_Buffer(void)
{
  unsigned char tmpRxTail;          // Temporary variable to store volatile
  tmpRxTail = TWI_RxTail;           // Not necessary, but prevents warnings
 106:	90 91 9e 00 	lds	r25, 0x009E	; 0x80009e <TWI_RxTail>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Slave/USI_TWI_Slave.c:137
  return (TWI_RxHead - tmpRxTail) & TWI_RX_BUFFER_MASK; // Return 0 (FALSE) if the receive buffer is empty.
 10a:	80 91 9d 00 	lds	r24, 0x009D	; 0x80009d <TWI_RxHead>
 10e:	89 1b       	sub	r24, r25
 110:	8f 70       	andi	r24, 0x0F	; 15
_ZN7TwoWire4readEv.constprop.32():
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/Wire.cpp:565

  // get each successive byte on each call
  if (available()) {
 112:	b1 f3       	breq	.-20     	; 0x100 <TwoWire::read() [clone .constprop.32]+0x10>
USI_TWI_Receive_Byte():
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Slave/USI_TWI_Slave.c:112
// Returns a byte from the receive buffer. Waits if buffer is empty.
unsigned char USI_TWI_Receive_Byte(void)
{
  unsigned char tmptail;
  unsigned char tmpRxTail; // Temporary variable to store volatile
  tmpRxTail = TWI_RxTail;  // Not necessary, but prevents warnings
 114:	90 91 9e 00 	lds	r25, 0x009E	; 0x80009e <TWI_RxTail>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Slave/USI_TWI_Slave.c:113
  while (TWI_RxHead == tmpRxTail)
 118:	80 91 9d 00 	lds	r24, 0x009D	; 0x80009d <TWI_RxHead>
 11c:	98 17       	cp	r25, r24
 11e:	e1 f3       	breq	.-8      	; 0x118 <TwoWire::read() [clone .constprop.32]+0x28>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Slave/USI_TWI_Slave.c:115
    ;
  tmptail    = (TWI_RxTail + 1) & TWI_RX_BUFFER_MASK; // Calculate buffer index
 120:	e0 91 9e 00 	lds	r30, 0x009E	; 0x80009e <TWI_RxTail>
 124:	ef 5f       	subi	r30, 0xFF	; 255
 126:	ef 70       	andi	r30, 0x0F	; 15
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Slave/USI_TWI_Slave.c:116
  TWI_RxTail = tmptail;                               // Store new index
 128:	e0 93 9e 00 	sts	0x009E, r30	; 0x80009e <TWI_RxTail>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Slave/USI_TWI_Slave.c:117
  return TWI_RxBuf[tmptail];                          // Return data from the buffer.
 12c:	f0 e0       	ldi	r31, 0x00	; 0
 12e:	e0 5a       	subi	r30, 0xA0	; 160
 130:	ff 4f       	sbci	r31, 0xFF	; 255
_ZN7TwoWire4readEv.constprop.32():
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/Wire.cpp:570
    if (BufferLength) {
      value = Buffer[BufferIndex];
      ++BufferIndex;
    } else {
      value = USI_TWI_Receive_Byte();
 132:	80 81       	ld	r24, Z
 134:	90 e0       	ldi	r25, 0x00	; 0
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/Wire.cpp:575
    }
  }

  return value;
}
 136:	08 95       	ret
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/Wire.cpp:567
  int value = -1;

  // get each successive byte on each call
  if (available()) {
    if (BufferLength) {
      value = Buffer[BufferIndex];
 138:	e2 2f       	mov	r30, r18
 13a:	f0 e0       	ldi	r31, 0x00	; 0
 13c:	e0 5a       	subi	r30, 0xA0	; 160
 13e:	ff 4f       	sbci	r31, 0xFF	; 255
 140:	80 81       	ld	r24, Z
 142:	90 e0       	ldi	r25, 0x00	; 0
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/Wire.cpp:568
      ++BufferIndex;
 144:	2f 5f       	subi	r18, 0xFF	; 255
 146:	20 93 a3 00 	sts	0x00A3, r18	; 0x8000a3 <TwoWire::BufferIndex>
 14a:	08 95       	ret

0000014c <delay>:
delay():
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring.c:833
    // us is at least 4, divided by 4 gives us 1 (no zero delay bug)
    us >>= 2; // us div 4, = 4 cycles
  #endif

  // busy wait
  __asm__ __volatile__ (
 14c:	24 ef       	ldi	r18, 0xF4	; 244
 14e:	30 e0       	ldi	r19, 0x00	; 0
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring.c:543
  }
  void yield(void) __attribute__ ((weak, alias("__empty")));

  void delay(unsigned long ms) //non-millis-timer-dependent delay()
  {
    while(ms--){
 150:	61 50       	subi	r22, 0x01	; 1
 152:	71 09       	sbc	r23, r1
 154:	81 09       	sbc	r24, r1
 156:	91 09       	sbc	r25, r1
 158:	08 f4       	brcc	.+2      	; 0x15c <delay+0x10>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring.c:547
      yield();
      delayMicroseconds(1000);
    }
  }
 15a:	08 95       	ret
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring.c:833
    // us is at least 4, divided by 4 gives us 1 (no zero delay bug)
    us >>= 2; // us div 4, = 4 cycles
  #endif

  // busy wait
  __asm__ __volatile__ (
 15c:	f9 01       	movw	r30, r18
 15e:	31 97       	sbiw	r30, 0x01	; 1
 160:	f1 f7       	brne	.-4      	; 0x15e <delay+0x12>
 162:	f6 cf       	rjmp	.-20     	; 0x150 <delay+0x4>

00000164 <USI_TWI_Master_Transfer>:
USI_TWI_Master_Transfer():
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Master/USI_TWI_Master.c:225
 Data to be sent has to be placed into the USIDR prior to calling
 this function. Data read, will be return'ed from the function.
---------------------------------------------------------------*/
unsigned char USI_TWI_Master_Transfer(unsigned char temp)
{
  USISR = temp;                                          // Set USISR according to temp.
 164:	8e b9       	out	0x0e, r24	; 14
_delay_loop_1():
/Users/aesters/Library/Arduino15/packages/arduino/tools/avr-gcc/7.3.0-atmel3.6.1-arduino7/avr/include/util/delay_basic.h:83
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
 166:	35 e0       	ldi	r19, 0x05	; 5
USI_TWI_Master_Transfer():
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Master/USI_TWI_Master.c:233
         (1 << USIWM1) | (0 << USIWM0) |                 // Set USI in Two-wire mode.
         (1 << USICS1) | (0 << USICS0) | (1 << USICLK) | // Software clock strobe as source.
         (1 << USITC);                                   // Toggle Clock Port.
  do {
    if (USI_TWI_MASTER_SPEED) DELAY_T2TWI_FM; else DELAY_T2TWI;
    USICR = temp; // Generate positive SCL edge.
 168:	8b e2       	ldi	r24, 0x2B	; 43
_delay_loop_1():
/Users/aesters/Library/Arduino15/packages/arduino/tools/avr-gcc/7.3.0-atmel3.6.1-arduino7/avr/include/util/delay_basic.h:83
 16a:	24 e0       	ldi	r18, 0x04	; 4
 16c:	93 2f       	mov	r25, r19
 16e:	9a 95       	dec	r25
 170:	f1 f7       	brne	.-4      	; 0x16e <USI_TWI_Master_Transfer+0xa>
USI_TWI_Master_Transfer():
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Master/USI_TWI_Master.c:233
 172:	8d b9       	out	0x0d, r24	; 13
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Master/USI_TWI_Master.c:234
    while (!(PIN_USI_CL & (1 << PIN_USI_SCL)))
 174:	b2 9b       	sbis	0x16, 2	; 22
 176:	fe cf       	rjmp	.-4      	; 0x174 <USI_TWI_Master_Transfer+0x10>
_delay_loop_1():
/Users/aesters/Library/Arduino15/packages/arduino/tools/avr-gcc/7.3.0-atmel3.6.1-arduino7/avr/include/util/delay_basic.h:83
 178:	92 2f       	mov	r25, r18
 17a:	9a 95       	dec	r25
 17c:	f1 f7       	brne	.-4      	; 0x17a <USI_TWI_Master_Transfer+0x16>
USI_TWI_Master_Transfer():
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Master/USI_TWI_Master.c:237
      ; // Wait for SCL to go high.
    if (USI_TWI_MASTER_SPEED) DELAY_T4TWI_FM; else DELAY_T4TWI;
    USICR = temp;                   // Generate negative SCL edge.
 17e:	8d b9       	out	0x0d, r24	; 13
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Master/USI_TWI_Master.c:238
  } while (!(USISR & (1 << USIOIF))); // Check for transfer complete.
 180:	76 9b       	sbis	0x0e, 6	; 14
 182:	f4 cf       	rjmp	.-24     	; 0x16c <USI_TWI_Master_Transfer+0x8>
_delay_loop_1():
/Users/aesters/Library/Arduino15/packages/arduino/tools/avr-gcc/7.3.0-atmel3.6.1-arduino7/avr/include/util/delay_basic.h:83
 184:	85 e0       	ldi	r24, 0x05	; 5
 186:	8a 95       	dec	r24
 188:	f1 f7       	brne	.-4      	; 0x186 <USI_TWI_Master_Transfer+0x22>
USI_TWI_Master_Transfer():
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Master/USI_TWI_Master.c:241

  if (USI_TWI_MASTER_SPEED) DELAY_T2TWI_FM; else DELAY_T2TWI;
  temp  = USIDR;                 // Read out data.
 18a:	8f b1       	in	r24, 0x0f	; 15
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Master/USI_TWI_Master.c:242
  USIDR = 0xFF;                  // Release SDA.
 18c:	9f ef       	ldi	r25, 0xFF	; 255
 18e:	9f b9       	out	0x0f, r25	; 15
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Master/USI_TWI_Master.c:243
  DDR_USI |= (1 << PIN_USI_SDA); // Enable SDA as output.
 190:	b8 9a       	sbi	0x17, 0	; 23
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Master/USI_TWI_Master.c:246

  return temp; // Return the data from the USIDR
}
 192:	08 95       	ret

00000194 <USI_TWI_Start_Transceiver_With_Data_Stop>:
USI_TWI_Start_Transceiver_With_Data_Stop():
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Master/USI_TWI_Master.c:108
 parameter that defines if a Stop Condition should be send at the end
 of the transmission.
---------------------------------------------------------------*/

unsigned char USI_TWI_Start_Transceiver_With_Data_Stop(unsigned char *msg, unsigned char msgSize, unsigned char stop)
{
 194:	ff 92       	push	r15
 196:	0f 93       	push	r16
 198:	1f 93       	push	r17
 19a:	cf 93       	push	r28
 19c:	df 93       	push	r29
 19e:	06 2f       	mov	r16, r22
 1a0:	14 2f       	mov	r17, r20
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Master/USI_TWI_Master.c:115
  // Prepare register value to: Clear flags set USI to shift 8 bits i.e. count 16 clock edges.

  unsigned char tempUSISR_1bit = (1 << USISIF) | (1 << USIOIF) | (1 << USIPF) | (1 << USIDC) | (0xE << USICNT0);
  // Prepare register value to: Clear flags, and set USI to shift 1 bit i.e. count 2 clock edges.

  USI_TWI_state.errorState  = 0;
 1a2:	21 e0       	ldi	r18, 0x01	; 1
 1a4:	20 93 a1 00 	sts	0x00A1, r18	; 0x8000a1 <USI_TWI_state>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Master/USI_TWI_Master.c:146
    USI_TWI_state.errorState = USI_TWI_UE_DATA_COL;
    return (FALSE);
  }
#endif

  if (!(*msg & (1 << TWI_READ_BIT))) // The LSB in the address byte determines if is a masterRead or masterWrite operation.
 1a8:	fc 01       	movw	r30, r24
 1aa:	20 81       	ld	r18, Z
 1ac:	20 fd       	sbrc	r18, 0
 1ae:	03 c0       	rjmp	.+6      	; 0x1b6 <USI_TWI_Start_Transceiver_With_Data_Stop+0x22>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Master/USI_TWI_Master.c:148
  {
    USI_TWI_state.masterWriteDataMode = TRUE;
 1b0:	23 e0       	ldi	r18, 0x03	; 3
 1b2:	20 93 a1 00 	sts	0x00A1, r18	; 0x8000a1 <USI_TWI_state>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Master/USI_TWI_Master.c:152
  }

  /* Release SCL to ensure that (repeated) Start can be performed */
  PORT_USI_CL |= (1 << PIN_USI_SCL); // Release SCL.
 1b6:	c2 9a       	sbi	0x18, 2	; 24
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Master/USI_TWI_Master.c:153
  while (!(PIN_USI_CL & (1 << PIN_USI_SCL)))
 1b8:	b2 9b       	sbis	0x16, 2	; 22
 1ba:	fe cf       	rjmp	.-4      	; 0x1b8 <USI_TWI_Start_Transceiver_With_Data_Stop+0x24>
_delay_loop_1():
/Users/aesters/Library/Arduino15/packages/arduino/tools/avr-gcc/7.3.0-atmel3.6.1-arduino7/avr/include/util/delay_basic.h:83
 1bc:	25 e0       	ldi	r18, 0x05	; 5
 1be:	2a 95       	dec	r18
 1c0:	f1 f7       	brne	.-4      	; 0x1be <USI_TWI_Start_Transceiver_With_Data_Stop+0x2a>
USI_TWI_Start_Transceiver_With_Data_Stop():
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Master/USI_TWI_Master.c:159
    ; // Verify that SCL becomes high.
  if (USI_TWI_MASTER_SPEED) DELAY_T4TWI_FM; // Delay for T4TWI if TWI_FAST_MODE
  else DELAY_T2TWI;    // Delay for T2TWI if TWI_STANDARD_MODE

  /* Generate Start Condition */
  PORT_USI &= ~(1 << PIN_USI_SDA); // Force SDA LOW.
 1c2:	c0 98       	cbi	0x18, 0	; 24
_delay_loop_1():
/Users/aesters/Library/Arduino15/packages/arduino/tools/avr-gcc/7.3.0-atmel3.6.1-arduino7/avr/include/util/delay_basic.h:83
 1c4:	24 e0       	ldi	r18, 0x04	; 4
 1c6:	2a 95       	dec	r18
 1c8:	f1 f7       	brne	.-4      	; 0x1c6 <USI_TWI_Start_Transceiver_With_Data_Stop+0x32>
USI_TWI_Start_Transceiver_With_Data_Stop():
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Master/USI_TWI_Master.c:163

  if (USI_TWI_MASTER_SPEED) DELAY_T4TWI_FM; else DELAY_T4TWI; // UGGGGLLLYYYYY - but if you never call clock() which is the only thing that could change USI_TWI_MASTER_SPEED, should be optimized out

  PORT_USI_CL &= ~(1 << PIN_USI_SCL); // Pull SCL LOW.
 1ca:	c2 98       	cbi	0x18, 2	; 24
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Master/USI_TWI_Master.c:164
  PORT_USI |= (1 << PIN_USI_SDA);  // Release SDA.
 1cc:	c0 9a       	sbi	0x18, 0	; 24
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Master/USI_TWI_Master.c:167

#ifdef SIGNAL_VERIFY
  if (!(USISR & (1 << USISIF))) {
 1ce:	77 99       	sbic	0x0e, 7	; 14
 1d0:	0b c0       	rjmp	.+22     	; 0x1e8 <USI_TWI_Start_Transceiver_With_Data_Stop+0x54>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Master/USI_TWI_Master.c:168
    USI_TWI_state.errorState = USI_TWI_MISSING_START_CON;
 1d2:	87 e0       	ldi	r24, 0x07	; 7
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Master/USI_TWI_Master.c:186

      /* Clock and verify (N)ACK from slave */
      DDR_USI &= ~(1 << PIN_USI_SDA); // Enable SDA as input.
      if (USI_TWI_Master_Transfer(tempUSISR_1bit) & (1 << TWI_NACK_BIT)) {
        if (USI_TWI_state.addressMode)
          USI_TWI_state.errorState = USI_TWI_NO_ACK_ON_ADDRESS;
 1d4:	80 93 a1 00 	sts	0x00A1, r24	; 0x8000a1 <USI_TWI_state>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Master/USI_TWI_Master.c:189
        else
          USI_TWI_state.errorState = USI_TWI_NO_ACK_ON_DATA;
        return (FALSE);
 1d8:	10 e0       	ldi	r17, 0x00	; 0
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Master/USI_TWI_Master.c:216
    USI_TWI_Master_Stop(); // Send a STOP condition on the TWI bus.
  }

  /* Transmission successfully completed*/
  return (TRUE);
}
 1da:	81 2f       	mov	r24, r17
 1dc:	df 91       	pop	r29
 1de:	cf 91       	pop	r28
 1e0:	1f 91       	pop	r17
 1e2:	0f 91       	pop	r16
 1e4:	ff 90       	pop	r15
 1e6:	08 95       	ret
 1e8:	ec 01       	movw	r28, r24
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Master/USI_TWI_Master.c:202
      *(msg++) = USI_TWI_Master_Transfer(tempUSISR_8bit);

      /* Prepare to generate ACK (or NACK in case of End Of Transmission) */
      if (msgSize == 1) // If transmission of last byte was performed.
      {
        USIDR = 0xFF; // Load NACK to confirm End Of Transmission.
 1ea:	ff 24       	eor	r15, r15
 1ec:	fa 94       	dec	r15
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Master/USI_TWI_Master.c:176
#endif

  /*Write address and Read/Write data */
  do {
    /* If masterWrite cycle (or initial address transmission)*/
    if (USI_TWI_state.addressMode || USI_TWI_state.masterWriteDataMode) {
 1ee:	80 91 a1 00 	lds	r24, 0x00A1	; 0x8000a1 <USI_TWI_state>
 1f2:	83 70       	andi	r24, 0x03	; 3
 1f4:	19 f1       	breq	.+70     	; 0x23c <USI_TWI_Start_Transceiver_With_Data_Stop+0xa8>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Master/USI_TWI_Master.c:178
      /* Write a byte */
      PORT_USI_CL &= ~(1 << PIN_USI_SCL);         // Pull SCL LOW.
 1f6:	c2 98       	cbi	0x18, 2	; 24
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Master/USI_TWI_Master.c:179
      USIDR = *(msg++);                        // Setup data.
 1f8:	88 81       	ld	r24, Y
 1fa:	8f b9       	out	0x0f, r24	; 15
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Master/USI_TWI_Master.c:180
      USI_TWI_Master_Transfer(tempUSISR_8bit); // Send 8 bits on bus.
 1fc:	80 ef       	ldi	r24, 0xF0	; 240
 1fe:	b2 df       	rcall	.-156    	; 0x164 <USI_TWI_Master_Transfer>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Master/USI_TWI_Master.c:183

      /* Clock and verify (N)ACK from slave */
      DDR_USI &= ~(1 << PIN_USI_SDA); // Enable SDA as input.
 200:	b8 98       	cbi	0x17, 0	; 23
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Master/USI_TWI_Master.c:184
      if (USI_TWI_Master_Transfer(tempUSISR_1bit) & (1 << TWI_NACK_BIT)) {
 202:	8e ef       	ldi	r24, 0xFE	; 254
 204:	af df       	rcall	.-162    	; 0x164 <USI_TWI_Master_Transfer>
 206:	80 ff       	sbrs	r24, 0
 208:	0c c0       	rjmp	.+24     	; 0x222 <USI_TWI_Start_Transceiver_With_Data_Stop+0x8e>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Master/USI_TWI_Master.c:185
        if (USI_TWI_state.addressMode)
 20a:	80 91 a1 00 	lds	r24, 0x00A1	; 0x8000a1 <USI_TWI_state>
 20e:	18 2f       	mov	r17, r24
 210:	11 70       	andi	r17, 0x01	; 1
 212:	80 ff       	sbrs	r24, 0
 214:	02 c0       	rjmp	.+4      	; 0x21a <USI_TWI_Start_Transceiver_With_Data_Stop+0x86>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Master/USI_TWI_Master.c:186
          USI_TWI_state.errorState = USI_TWI_NO_ACK_ON_ADDRESS;
 216:	86 e0       	ldi	r24, 0x06	; 6
 218:	dd cf       	rjmp	.-70     	; 0x1d4 <USI_TWI_Start_Transceiver_With_Data_Stop+0x40>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Master/USI_TWI_Master.c:188
        else
          USI_TWI_state.errorState = USI_TWI_NO_ACK_ON_DATA;
 21a:	85 e0       	ldi	r24, 0x05	; 5
USI_TWI_Master_Stop():
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Master/USI_TWI_Master.c:264
  PORT_USI |= (1 << PIN_USI_SDA); // Release SDA.
  if (USI_TWI_MASTER_SPEED) DELAY_T2TWI_FM; else DELAY_T2TWI;

#ifdef SIGNAL_VERIFY
  if (!(USISR & (1 << USIPF))) {
    USI_TWI_state.errorState = USI_TWI_MISSING_STOP_CON;
 21c:	80 93 a1 00 	sts	0x00A1, r24	; 0x8000a1 <USI_TWI_state>
 220:	dc cf       	rjmp	.-72     	; 0x1da <USI_TWI_Start_Transceiver_With_Data_Stop+0x46>
USI_TWI_Start_Transceiver_With_Data_Stop():
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Master/USI_TWI_Master.c:191
          USI_TWI_state.errorState = USI_TWI_NO_ACK_ON_ADDRESS;
        else
          USI_TWI_state.errorState = USI_TWI_NO_ACK_ON_DATA;
        return (FALSE);
      }
      USI_TWI_state.addressMode = FALSE; // Only perform address transmission once.
 222:	80 91 a1 00 	lds	r24, 0x00A1	; 0x8000a1 <USI_TWI_state>
 226:	8e 7f       	andi	r24, 0xFE	; 254
 228:	80 93 a1 00 	sts	0x00A1, r24	; 0x8000a1 <USI_TWI_state>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Master/USI_TWI_Master.c:208
      } else {
        USIDR = 0x00; // Load ACK. Set data register bit 7 (output for SDA) low.
      }
      USI_TWI_Master_Transfer(tempUSISR_1bit); // Generate ACK/NACK.
    }
  } while (--msgSize); // Until all data sent/received.
 22c:	01 50       	subi	r16, 0x01	; 1
 22e:	21 96       	adiw	r28, 0x01	; 1
 230:	01 11       	cpse	r16, r1
 232:	dd cf       	rjmp	.-70     	; 0x1ee <USI_TWI_Start_Transceiver_With_Data_Stop+0x5a>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Master/USI_TWI_Master.c:210

  if (stop) {
 234:	11 11       	cpse	r17, r1
 236:	0e c0       	rjmp	.+28     	; 0x254 <USI_TWI_Start_Transceiver_With_Data_Stop+0xc0>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Master/USI_TWI_Master.c:215
    USI_TWI_Master_Stop(); // Send a STOP condition on the TWI bus.
  }

  /* Transmission successfully completed*/
  return (TRUE);
 238:	11 e0       	ldi	r17, 0x01	; 1
 23a:	cf cf       	rjmp	.-98     	; 0x1da <USI_TWI_Start_Transceiver_With_Data_Stop+0x46>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Master/USI_TWI_Master.c:196
      USI_TWI_state.addressMode = FALSE; // Only perform address transmission once.
    }
    /* Else masterRead cycle*/
    else {
      /* Read a data byte */
      DDR_USI &= ~(1 << PIN_USI_SDA); // Enable SDA as input.
 23c:	b8 98       	cbi	0x17, 0	; 23
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Master/USI_TWI_Master.c:197
      *(msg++) = USI_TWI_Master_Transfer(tempUSISR_8bit);
 23e:	80 ef       	ldi	r24, 0xF0	; 240
 240:	91 df       	rcall	.-222    	; 0x164 <USI_TWI_Master_Transfer>
 242:	88 83       	st	Y, r24
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Master/USI_TWI_Master.c:200

      /* Prepare to generate ACK (or NACK in case of End Of Transmission) */
      if (msgSize == 1) // If transmission of last byte was performed.
 244:	01 30       	cpi	r16, 0x01	; 1
 246:	21 f4       	brne	.+8      	; 0x250 <USI_TWI_Start_Transceiver_With_Data_Stop+0xbc>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Master/USI_TWI_Master.c:202
      {
        USIDR = 0xFF; // Load NACK to confirm End Of Transmission.
 248:	ff b8       	out	0x0f, r15	; 15
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Master/USI_TWI_Master.c:206
      } else {
        USIDR = 0x00; // Load ACK. Set data register bit 7 (output for SDA) low.
      }
      USI_TWI_Master_Transfer(tempUSISR_1bit); // Generate ACK/NACK.
 24a:	8e ef       	ldi	r24, 0xFE	; 254
 24c:	8b df       	rcall	.-234    	; 0x164 <USI_TWI_Master_Transfer>
 24e:	ee cf       	rjmp	.-36     	; 0x22c <USI_TWI_Start_Transceiver_With_Data_Stop+0x98>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Master/USI_TWI_Master.c:204
      /* Prepare to generate ACK (or NACK in case of End Of Transmission) */
      if (msgSize == 1) // If transmission of last byte was performed.
      {
        USIDR = 0xFF; // Load NACK to confirm End Of Transmission.
      } else {
        USIDR = 0x00; // Load ACK. Set data register bit 7 (output for SDA) low.
 250:	1f b8       	out	0x0f, r1	; 15
 252:	fb cf       	rjmp	.-10     	; 0x24a <USI_TWI_Start_Transceiver_With_Data_Stop+0xb6>
USI_TWI_Master_Stop():
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Master/USI_TWI_Master.c:254
 Function for generating a TWI Stop Condition. Used to release
 the TWI bus.
---------------------------------------------------------------*/
unsigned char USI_TWI_Master_Stop(void)
{
  PORT_USI &= ~(1 << PIN_USI_SDA); // Pull SDA low.
 254:	c0 98       	cbi	0x18, 0	; 24
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Master/USI_TWI_Master.c:255
  PORT_USI_CL |= (1 << PIN_USI_SCL);  // Release SCL.
 256:	c2 9a       	sbi	0x18, 2	; 24
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Master/USI_TWI_Master.c:256
  while (!(PIN_USI_CL & (1 << PIN_USI_SCL)))
 258:	b2 9b       	sbis	0x16, 2	; 22
 25a:	fe cf       	rjmp	.-4      	; 0x258 <USI_TWI_Start_Transceiver_With_Data_Stop+0xc4>
_delay_loop_1():
/Users/aesters/Library/Arduino15/packages/arduino/tools/avr-gcc/7.3.0-atmel3.6.1-arduino7/avr/include/util/delay_basic.h:83
 25c:	84 e0       	ldi	r24, 0x04	; 4
 25e:	8a 95       	dec	r24
 260:	f1 f7       	brne	.-4      	; 0x25e <USI_TWI_Start_Transceiver_With_Data_Stop+0xca>
USI_TWI_Master_Stop():
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Master/USI_TWI_Master.c:259
    ; // Wait for SCL to go high.
  if (USI_TWI_MASTER_SPEED) DELAY_T4TWI_FM; else DELAY_T4TWI;
  PORT_USI |= (1 << PIN_USI_SDA); // Release SDA.
 262:	c0 9a       	sbi	0x18, 0	; 24
_delay_loop_1():
/Users/aesters/Library/Arduino15/packages/arduino/tools/avr-gcc/7.3.0-atmel3.6.1-arduino7/avr/include/util/delay_basic.h:83
 264:	85 e0       	ldi	r24, 0x05	; 5
 266:	8a 95       	dec	r24
 268:	f1 f7       	brne	.-4      	; 0x266 <__stack+0x7>
USI_TWI_Master_Stop():
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Master/USI_TWI_Master.c:263
  if (USI_TWI_MASTER_SPEED) DELAY_T2TWI_FM; else DELAY_T2TWI;

#ifdef SIGNAL_VERIFY
  if (!(USISR & (1 << USIPF))) {
 26a:	75 99       	sbic	0x0e, 5	; 14
 26c:	e5 cf       	rjmp	.-54     	; 0x238 <USI_TWI_Start_Transceiver_With_Data_Stop+0xa4>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Master/USI_TWI_Master.c:264
    USI_TWI_state.errorState = USI_TWI_MISSING_STOP_CON;
 26e:	88 e0       	ldi	r24, 0x08	; 8
 270:	d5 cf       	rjmp	.-86     	; 0x21c <USI_TWI_Start_Transceiver_With_Data_Stop+0x88>

00000272 <TwoWire::endTransmission() [clone .constprop.40]>:
_ZN7TwoWire15endTransmissionEv.constprop.40():
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/Wire.cpp:478

uint8_t TwoWire::endTransmission(uint8_t sendStop) {
  // transmit buffer (blocking)
  uint8_t ret = USI_TWI_Start_Transceiver_With_Data_Stop(Buffer,
                                                         BufferLength,
                                                         sendStop);
 272:	41 e0       	ldi	r20, 0x01	; 1
 274:	60 91 a4 00 	lds	r22, 0x00A4	; 0x8000a4 <TwoWire::BufferLength>
 278:	80 e6       	ldi	r24, 0x60	; 96
 27a:	90 e0       	ldi	r25, 0x00	; 0
 27c:	8b df       	rcall	.-234    	; 0x194 <USI_TWI_Start_Transceiver_With_Data_Stop>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/Wire.cpp:480
  // reset tx buffer iterator vars
  BufferIndex = 0;
 27e:	10 92 a3 00 	sts	0x00A3, r1	; 0x8000a3 <TwoWire::BufferIndex>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/Wire.cpp:481
  BufferLength = 0;
 282:	10 92 a4 00 	sts	0x00A4, r1	; 0x8000a4 <TwoWire::BufferLength>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/Wire.cpp:483
  // indicate that we are done transmitting
  transmitting = 0;
 286:	10 92 a2 00 	sts	0x00A2, r1	; 0x8000a2 <TwoWire::transmitting>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/Wire.cpp:485
  // check for error
  if (ret == FALSE) {
 28a:	81 11       	cpse	r24, r1
 28c:	10 c0       	rjmp	.+32     	; 0x2ae <TwoWire::endTransmission() [clone .constprop.40]+0x3c>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/Wire.cpp:486
    switch (USI_TWI_Get_State_Info()) {
 28e:	80 91 a1 00 	lds	r24, 0x00A1	; 0x8000a1 <USI_TWI_state>
 292:	85 30       	cpi	r24, 0x05	; 5
 294:	41 f0       	breq	.+16     	; 0x2a6 <TwoWire::endTransmission() [clone .constprop.40]+0x34>
 296:	86 30       	cpi	r24, 0x06	; 6
 298:	21 f0       	breq	.+8      	; 0x2a2 <TwoWire::endTransmission() [clone .constprop.40]+0x30>
 29a:	81 30       	cpi	r24, 0x01	; 1
 29c:	31 f4       	brne	.+12     	; 0x2aa <TwoWire::endTransmission() [clone .constprop.40]+0x38>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/Wire.cpp:488
    case USI_TWI_DATA_OUT_OF_BOUND:
      return 1; //data too long to fit in transmit buffer
 29e:	81 e0       	ldi	r24, 0x01	; 1
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/Wire.cpp:501
  return 0; //success
}

uint8_t TwoWire::endTransmission(void) {
  return endTransmission(true);
}
 2a0:	08 95       	ret
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/Wire.cpp:490
  if (ret == FALSE) {
    switch (USI_TWI_Get_State_Info()) {
    case USI_TWI_DATA_OUT_OF_BOUND:
      return 1; //data too long to fit in transmit buffer
    case USI_TWI_NO_ACK_ON_ADDRESS:
      return 2; //received NACK on transmit of address
 2a2:	82 e0       	ldi	r24, 0x02	; 2
 2a4:	08 95       	ret
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/Wire.cpp:492
    case USI_TWI_NO_ACK_ON_DATA:
      return 3; //received NACK on transmit of data
 2a6:	83 e0       	ldi	r24, 0x03	; 3
 2a8:	08 95       	ret
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/Wire.cpp:494
    }
    return 4; //other error
 2aa:	84 e0       	ldi	r24, 0x04	; 4
 2ac:	08 95       	ret
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/Wire.cpp:496
  }
  return 0; //success
 2ae:	80 e0       	ldi	r24, 0x00	; 0
 2b0:	08 95       	ret

000002b2 <i2cWrite(unsigned char, unsigned char, unsigned char, unsigned char, bool) [clone .constprop.37]>:
_Z8i2cWritehhhhb.constprop.37():
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:87
  // return in specified format
  return static_cast<T>(rawValue);
}

// I2C write operation
void i2cWrite(uint8_t command, uint8_t deviceAddress, uint8_t startRegister, uint8_t numBytes, bool bigEndian = false) 
 2b2:	cf 93       	push	r28
 2b4:	df 93       	push	r29
 2b6:	c8 2f       	mov	r28, r24
 2b8:	86 2f       	mov	r24, r22
 2ba:	d4 2f       	mov	r29, r20
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:90
{ 
  // start I2C comms with device
  Wire.beginTransmission(deviceAddress);
 2bc:	0e df       	rcall	.-484    	; 0xda <TwoWire::beginTransmission(unsigned char) [clone .constprop.38]>
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:93

  // write one byte to each consecutive register
  Wire.write(startRegister);      
 2be:	8d 2f       	mov	r24, r29
 2c0:	d9 de       	rcall	.-590    	; 0x74 <TwoWire::write(unsigned char) [clone .constprop.39]>
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:104
      currentByte = 0xFF & (command >> 8*(numBytes - 1 - i));
    }
    else {
      currentByte = 0xFF & (command >> 8*i);
    }
    Wire.write(currentByte);
 2c2:	8c 2f       	mov	r24, r28
 2c4:	d7 de       	rcall	.-594    	; 0x74 <TwoWire::write(unsigned char) [clone .constprop.39]>
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:108
    // device auto-increments register after each write
  }
  Wire.endTransmission();
}
 2c6:	df 91       	pop	r29
 2c8:	cf 91       	pop	r28
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:107
      currentByte = 0xFF & (command >> 8*i);
    }
    Wire.write(currentByte);
    // device auto-increments register after each write
  }
  Wire.endTransmission();
 2ca:	d3 cf       	rjmp	.-90     	; 0x272 <TwoWire::endTransmission() [clone .constprop.40]>

000002cc <I2C_WriteRegister.constprop.35>:
I2C_WriteRegister.constprop.35():
/Users/aesters/Documents/Arduino/libraries/vcnl4020-arduino-driver/src/VCNL4020.cpp:227
    // device auto-increments register after each read
  }
  return reg_value;
}

void I2C_WriteRegister(uint8_t dev_address, uint8_t reg_address, uint8_t length, uint16_t data) 
 2cc:	cf 93       	push	r28
 2ce:	df 93       	push	r29
 2d0:	d6 2f       	mov	r29, r22
 2d2:	c4 2f       	mov	r28, r20
/Users/aesters/Documents/Arduino/libraries/vcnl4020-arduino-driver/src/VCNL4020.cpp:233
{
    uint8_t this_byte = 0;
    uint8_t n_bitshifts = 0;

    // start I2C comms with device
    Wire.beginTransmission(dev_address);  
 2d4:	02 df       	rcall	.-508    	; 0xda <TwoWire::beginTransmission(unsigned char) [clone .constprop.38]>
/Users/aesters/Documents/Arduino/libraries/vcnl4020-arduino-driver/src/VCNL4020.cpp:236

    // set target register for writing
    Wire.write(reg_address);
 2d6:	8d 2f       	mov	r24, r29
 2d8:	cd de       	rcall	.-614    	; 0x74 <TwoWire::write(unsigned char) [clone .constprop.39]>
/Users/aesters/Documents/Arduino/libraries/vcnl4020-arduino-driver/src/VCNL4020.cpp:242

    // write data to registers in big-endian order
    for (int i = 0; i < length; i++) {
        n_bitshifts = 8 * (length - 1 - i);      
        this_byte = (data >> n_bitshifts) & 0xFF; // extract byte to send  
        Wire.write(this_byte);
 2da:	8c 2f       	mov	r24, r28
 2dc:	cb de       	rcall	.-618    	; 0x74 <TwoWire::write(unsigned char) [clone .constprop.39]>
/Users/aesters/Documents/Arduino/libraries/vcnl4020-arduino-driver/src/VCNL4020.cpp:246
        // device auto-increments register after each write
    }
    Wire.endTransmission();
}
 2de:	df 91       	pop	r29
 2e0:	cf 91       	pop	r28
/Users/aesters/Documents/Arduino/libraries/vcnl4020-arduino-driver/src/VCNL4020.cpp:245
        n_bitshifts = 8 * (length - 1 - i);      
        this_byte = (data >> n_bitshifts) & 0xFF; // extract byte to send  
        Wire.write(this_byte);
        // device auto-increments register after each write
    }
    Wire.endTransmission();
 2e2:	c7 cf       	rjmp	.-114    	; 0x272 <TwoWire::endTransmission() [clone .constprop.40]>

000002e4 <void STC3115::write<unsigned char>(unsigned char, unsigned char, unsigned char) [clone .isra.1] [clone .constprop.15]>:
_ZN7STC31155writeIhEEvT_hh.isra.1.constprop.15():
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.h:94
  return static_cast<T>(rawValue);
};

// I2C write operation
template <typename T>
void STC3115::write(T command, uint8_t startRegister, uint8_t numBytes) 
 2e4:	cf 93       	push	r28
 2e6:	df 93       	push	r29
 2e8:	c6 2f       	mov	r28, r22
 2ea:	d4 2f       	mov	r29, r20
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.h:97
{ 
  // start I2C comms with device
  Wire.beginTransmission(_address);
 2ec:	f6 de       	rcall	.-532    	; 0xda <TwoWire::beginTransmission(unsigned char) [clone .constprop.38]>
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.h:100

  // write one byte to each consecutive register
  Wire.write(startRegister);      
 2ee:	8d 2f       	mov	r24, r29
 2f0:	c1 de       	rcall	.-638    	; 0x74 <TwoWire::write(unsigned char) [clone .constprop.39]>
write():
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/Wire.h:157
    uint8_t isActive(void);

    inline size_t write(unsigned long n) { return write((uint8_t)n); }
    inline size_t write(long n) { return write((uint8_t)n); }
    inline size_t write(unsigned int n) { return write((uint8_t)n); }
    inline size_t write(int n) { return write((uint8_t)n); }
 2f2:	8c 2f       	mov	r24, r28
 2f4:	bf de       	rcall	.-642    	; 0x74 <TwoWire::write(unsigned char) [clone .constprop.39]>
_ZN7STC31155writeIhEEvT_hh.isra.1.constprop.15():
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.h:107
    Wire.write(command & 0xFF);   // send lower 8 bits
    command = command >> 8;       // shift to prepare next byte
    // device auto-increments register after each write
  }
  Wire.endTransmission();
};
 2f6:	df 91       	pop	r29
 2f8:	cf 91       	pop	r28
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.h:106
  for (int i = 0; i < numBytes; i++) { 
    Wire.write(command & 0xFF);   // send lower 8 bits
    command = command >> 8;       // shift to prepare next byte
    // device auto-increments register after each write
  }
  Wire.endTransmission();
 2fa:	bb cf       	rjmp	.-138    	; 0x272 <TwoWire::endTransmission() [clone .constprop.40]>

000002fc <void STC3115::write<unsigned int>(unsigned int, unsigned char, unsigned char) [clone .isra.3] [clone .constprop.13]>:
_ZN7STC31155writeIjEEvT_hh.isra.3.constprop.13():
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.h:94
  return static_cast<T>(rawValue);
};

// I2C write operation
template <typename T>
void STC3115::write(T command, uint8_t startRegister, uint8_t numBytes) 
 2fc:	1f 93       	push	r17
 2fe:	cf 93       	push	r28
 300:	df 93       	push	r29
 302:	d6 2f       	mov	r29, r22
 304:	c7 2f       	mov	r28, r23
 306:	14 2f       	mov	r17, r20
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.h:97
{ 
  // start I2C comms with device
  Wire.beginTransmission(_address);
 308:	e8 de       	rcall	.-560    	; 0xda <TwoWire::beginTransmission(unsigned char) [clone .constprop.38]>
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.h:100

  // write one byte to each consecutive register
  Wire.write(startRegister);      
 30a:	81 2f       	mov	r24, r17
 30c:	b3 de       	rcall	.-666    	; 0x74 <TwoWire::write(unsigned char) [clone .constprop.39]>
write():
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/Wire.h:156
    void onRequest( void (*)(void) );
    uint8_t isActive(void);

    inline size_t write(unsigned long n) { return write((uint8_t)n); }
    inline size_t write(long n) { return write((uint8_t)n); }
    inline size_t write(unsigned int n) { return write((uint8_t)n); }
 30e:	8d 2f       	mov	r24, r29
 310:	b1 de       	rcall	.-670    	; 0x74 <TwoWire::write(unsigned char) [clone .constprop.39]>
 312:	8c 2f       	mov	r24, r28
 314:	af de       	rcall	.-674    	; 0x74 <TwoWire::write(unsigned char) [clone .constprop.39]>
_ZN7STC31155writeIjEEvT_hh.isra.3.constprop.13():
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.h:107
    Wire.write(command & 0xFF);   // send lower 8 bits
    command = command >> 8;       // shift to prepare next byte
    // device auto-increments register after each write
  }
  Wire.endTransmission();
};
 316:	df 91       	pop	r29
 318:	cf 91       	pop	r28
 31a:	1f 91       	pop	r17
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.h:106
  for (int i = 0; i < numBytes; i++) { 
    Wire.write(command & 0xFF);   // send lower 8 bits
    command = command >> 8;       // shift to prepare next byte
    // device auto-increments register after each write
  }
  Wire.endTransmission();
 31c:	aa cf       	rjmp	.-172    	; 0x272 <TwoWire::endTransmission() [clone .constprop.40]>

0000031e <goToSleep()>:
_Z9goToSleepv():
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:286
}

// Place MCU in power-down mode
void goToSleep() 
{
  set_sleep_mode(SLEEP_MODE_PWR_DOWN); // Use power-down mode
 31e:	85 b7       	in	r24, 0x35	; 53
 320:	87 7e       	andi	r24, 0xE7	; 231
 322:	80 61       	ori	r24, 0x10	; 16
 324:	85 bf       	out	0x35, r24	; 53
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:287
  sleep_enable();
 326:	85 b7       	in	r24, 0x35	; 53
 328:	80 62       	ori	r24, 0x20	; 32
 32a:	85 bf       	out	0x35, r24	; 53
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:288
  sleep_mode();    // Go to sleep
 32c:	85 b7       	in	r24, 0x35	; 53
 32e:	80 62       	ori	r24, 0x20	; 32
 330:	85 bf       	out	0x35, r24	; 53
 332:	88 95       	sleep
 334:	85 b7       	in	r24, 0x35	; 53
 336:	8f 7d       	andi	r24, 0xDF	; 223
 338:	85 bf       	out	0x35, r24	; 53
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:289
  sleep_disable(); // Resume here after wake-up
 33a:	85 b7       	in	r24, 0x35	; 53
 33c:	8f 7d       	andi	r24, 0xDF	; 223
 33e:	85 bf       	out	0x35, r24	; 53
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:290
}
 340:	08 95       	ret

00000342 <TwoWire::requestFrom(unsigned char, unsigned char) [clone .constprop.29]>:
_ZN7TwoWire11requestFromEhh.constprop.29():
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/Wire.cpp:448
                             uint8_t sendStop) {
  return requestFrom((uint8_t)address, (uint8_t)quantity, (uint32_t)0,
                     (uint8_t)0, (uint8_t)sendStop);
}

uint8_t TwoWire::requestFrom(uint8_t address, uint8_t quantity) {
 342:	cf 93       	push	r28
 344:	df 93       	push	r29
 346:	c6 2f       	mov	r28, r22
requestFrom():
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/Wire.cpp:420
    }
    endTransmission(false);
  }

  // reserve one byte for slave address
  quantity++;
 348:	d1 e0       	ldi	r29, 0x01	; 1
 34a:	d6 0f       	add	r29, r22
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/Wire.cpp:426
  // clamp to buffer length
  if (quantity > TWI_BUFFER_SIZE) {
    quantity = TWI_BUFFER_SIZE;
  }
  // set address of targeted slave and read mode
  Buffer[0] = (address << TWI_ADR_BITS) | (1 << TWI_READ_BIT);
 34c:	88 0f       	add	r24, r24
 34e:	81 60       	ori	r24, 0x01	; 1
 350:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/Wire.cpp:429
  // perform blocking read into buffer
  uint8_t ret = USI_TWI_Start_Transceiver_With_Data_Stop(Buffer, quantity,
                                                         sendStop);
 354:	41 e0       	ldi	r20, 0x01	; 1
 356:	6d 2f       	mov	r22, r29
 358:	80 e6       	ldi	r24, 0x60	; 96
 35a:	90 e0       	ldi	r25, 0x00	; 0
 35c:	1b df       	rcall	.-458    	; 0x194 <USI_TWI_Start_Transceiver_With_Data_Stop>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/Wire.cpp:431
  // set rx buffer iterator vars
  BufferIndex = 1; // ignore slave address
 35e:	91 e0       	ldi	r25, 0x01	; 1
 360:	90 93 a3 00 	sts	0x00A3, r25	; 0x8000a3 <TwoWire::BufferIndex>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/Wire.cpp:433
  // check for error
  if (ret == FALSE) {
 364:	81 11       	cpse	r24, r1
 366:	05 c0       	rjmp	.+10     	; 0x372 <TwoWire::requestFrom(unsigned char, unsigned char) [clone .constprop.29]+0x30>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/Wire.cpp:434
    BufferLength = BufferIndex;
 368:	90 93 a4 00 	sts	0x00A4, r25	; 0x8000a4 <TwoWire::BufferLength>
_ZN7TwoWire11requestFromEhh.constprop.29():
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/Wire.cpp:450
                     (uint8_t)0, (uint8_t)sendStop);
}

uint8_t TwoWire::requestFrom(uint8_t address, uint8_t quantity) {
  return requestFrom((uint8_t)address, (uint8_t)quantity, (uint8_t)true);
}
 36c:	df 91       	pop	r29
 36e:	cf 91       	pop	r28
 370:	08 95       	ret
requestFrom():
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/Wire.cpp:437
  // check for error
  if (ret == FALSE) {
    BufferLength = BufferIndex;
    return 0;
  }
  BufferLength = quantity;
 372:	d0 93 a4 00 	sts	0x00A4, r29	; 0x8000a4 <TwoWire::BufferLength>
_ZN7TwoWire11requestFromEhh.constprop.29():
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/Wire.cpp:439

  return quantity - 1; // ignore slave address
 376:	8c 2f       	mov	r24, r28
 378:	f9 cf       	rjmp	.-14     	; 0x36c <TwoWire::requestFrom(unsigned char, unsigned char) [clone .constprop.29]+0x2a>

0000037a <unsigned char STC3115::read<unsigned char>(unsigned char, unsigned char) [clone .isra.0] [clone .constprop.17]>:
_ZN7STC31154readIhEET_hh.isra.0.constprop.17():
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.h:69
    bool _debug;                         // debug flag
};

// I2C read operation (max read: 2 bytes)
template <typename T>
T STC3115::read(uint8_t startRegister, uint8_t numBytes) 
 37a:	1f 93       	push	r17
 37c:	cf 93       	push	r28
 37e:	df 93       	push	r29
 380:	18 2f       	mov	r17, r24
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.h:74
{ 
  uint16_t rawValue = 0;   // max: 2 bytes worth  

  // start I2C comms with device
  Wire.beginTransmission(_address);  
 382:	c8 e8       	ldi	r28, 0x88	; 136
 384:	d0 e0       	ldi	r29, 0x00	; 0
 386:	88 81       	ld	r24, Y
 388:	a8 de       	rcall	.-688    	; 0xda <TwoWire::beginTransmission(unsigned char) [clone .constprop.38]>
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.h:77

  // set target register for reading
  Wire.write(startRegister);
 38a:	81 2f       	mov	r24, r17
 38c:	73 de       	rcall	.-794    	; 0x74 <TwoWire::write(unsigned char) [clone .constprop.39]>
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.h:78
  Wire.endTransmission();
 38e:	71 df       	rcall	.-286    	; 0x272 <TwoWire::endTransmission() [clone .constprop.40]>
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.h:81

  // read contents from consecutive registers (little-endian format)
  Wire.requestFrom(_address, numBytes); 
 390:	61 e0       	ldi	r22, 0x01	; 1
 392:	88 81       	ld	r24, Y
 394:	d6 df       	rcall	.-84     	; 0x342 <TwoWire::requestFrom(unsigned char, unsigned char) [clone .constprop.29]>
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.h:83
  for (int i = 0; i < numBytes; i++) {    
    uint8_t nextByte = Wire.read();
 396:	ac de       	rcall	.-680    	; 0xf0 <TwoWire::read() [clone .constprop.32]>
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.h:90
    // device auto-increments register after each read
  }

  // returned in specified format
  return static_cast<T>(rawValue);
};
 398:	df 91       	pop	r29
 39a:	cf 91       	pop	r28
 39c:	1f 91       	pop	r17
 39e:	08 95       	ret

000003a0 <STC3115::run() [clone .constprop.7]>:
_ZN7STC31153runEv.constprop.7():
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:140
  // update RAM with new parameters
  updateRAM();
}

// Set component to "Run" mode
void STC3115::run()
 3a0:	cf 93       	push	r28
 3a2:	df 93       	push	r29
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:145
{
  DEBUG_PRINT("Switching to \"Run\" mode...");

  // clear alarm bits
  uint8_t tempCtrl = read<uint8_t>(REG_CTRL, 1);
 3a4:	81 e0       	ldi	r24, 0x01	; 1
 3a6:	e9 df       	rcall	.-46     	; 0x37a <unsigned char STC3115::read<unsigned char>(unsigned char, unsigned char) [clone .isra.0] [clone .constprop.17]>
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:146
  tempCtrl &= ~(0b11 << 5);     // set bits 5 and 6 to "0"
 3a8:	68 2f       	mov	r22, r24
 3aa:	6f 79       	andi	r22, 0x9F	; 159
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:147
  write<uint8_t>(tempCtrl, REG_CTRL, 1);
 3ac:	c8 e8       	ldi	r28, 0x88	; 136
 3ae:	d0 e0       	ldi	r29, 0x00	; 0
 3b0:	41 e0       	ldi	r20, 0x01	; 1
 3b2:	88 81       	ld	r24, Y
 3b4:	97 df       	rcall	.-210    	; 0x2e4 <void STC3115::write<unsigned char>(unsigned char, unsigned char, unsigned char) [clone .isra.1] [clone .constprop.15]>
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:150

  // set to mixed mode and disable alarm function 
  write<uint8_t>(1 << 4, REG_MODE, 1);     // only bit 4 is "1"    
 3b6:	40 e0       	ldi	r20, 0x00	; 0
 3b8:	60 e1       	ldi	r22, 0x10	; 16
 3ba:	88 81       	ld	r24, Y
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:151
}
 3bc:	df 91       	pop	r29
 3be:	cf 91       	pop	r28
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:150
  uint8_t tempCtrl = read<uint8_t>(REG_CTRL, 1);
  tempCtrl &= ~(0b11 << 5);     // set bits 5 and 6 to "0"
  write<uint8_t>(tempCtrl, REG_CTRL, 1);

  // set to mixed mode and disable alarm function 
  write<uint8_t>(1 << 4, REG_MODE, 1);     // only bit 4 is "1"    
 3c0:	91 cf       	rjmp	.-222    	; 0x2e4 <void STC3115::write<unsigned char>(unsigned char, unsigned char, unsigned char) [clone .isra.1] [clone .constprop.15]>

000003c2 <unsigned int STC3115::read<unsigned int>(unsigned char, unsigned char) [clone .isra.2] [clone .constprop.12]>:
_ZN7STC31154readIjEET_hh.isra.2.constprop.12():
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.h:69
    bool _debug;                         // debug flag
};

// I2C read operation (max read: 2 bytes)
template <typename T>
T STC3115::read(uint8_t startRegister, uint8_t numBytes) 
 3c2:	1f 93       	push	r17
 3c4:	cf 93       	push	r28
 3c6:	df 93       	push	r29
 3c8:	18 2f       	mov	r17, r24
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.h:74
{ 
  uint16_t rawValue = 0;   // max: 2 bytes worth  

  // start I2C comms with device
  Wire.beginTransmission(_address);  
 3ca:	c8 e8       	ldi	r28, 0x88	; 136
 3cc:	d0 e0       	ldi	r29, 0x00	; 0
 3ce:	88 81       	ld	r24, Y
 3d0:	84 de       	rcall	.-760    	; 0xda <TwoWire::beginTransmission(unsigned char) [clone .constprop.38]>
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.h:77

  // set target register for reading
  Wire.write(startRegister);
 3d2:	81 2f       	mov	r24, r17
 3d4:	4f de       	rcall	.-866    	; 0x74 <TwoWire::write(unsigned char) [clone .constprop.39]>
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.h:78
  Wire.endTransmission();
 3d6:	4d df       	rcall	.-358    	; 0x272 <TwoWire::endTransmission() [clone .constprop.40]>
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.h:81

  // read contents from consecutive registers (little-endian format)
  Wire.requestFrom(_address, numBytes); 
 3d8:	62 e0       	ldi	r22, 0x02	; 2
 3da:	88 81       	ld	r24, Y
 3dc:	b2 df       	rcall	.-156    	; 0x342 <TwoWire::requestFrom(unsigned char, unsigned char) [clone .constprop.29]>
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.h:83
  for (int i = 0; i < numBytes; i++) {    
    uint8_t nextByte = Wire.read();
 3de:	88 de       	rcall	.-752    	; 0xf0 <TwoWire::read() [clone .constprop.32]>
 3e0:	c8 2f       	mov	r28, r24
 3e2:	86 de       	rcall	.-756    	; 0xf0 <TwoWire::read() [clone .constprop.32]>
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.h:84
    rawValue |= uint16_t (nextByte << (8*i));    // shift new byte into proper position
 3e4:	20 e0       	ldi	r18, 0x00	; 0
 3e6:	38 2f       	mov	r19, r24
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.h:90
    // device auto-increments register after each read
  }

  // returned in specified format
  return static_cast<T>(rawValue);
};
 3e8:	c9 01       	movw	r24, r18
 3ea:	8c 2b       	or	r24, r28
 3ec:	df 91       	pop	r29
 3ee:	cf 91       	pop	r28
 3f0:	1f 91       	pop	r17
 3f2:	08 95       	ret

000003f4 <STC3115::setParameters() [clone .constprop.10]>:
_ZN7STC311513setParametersEv.constprop.10():
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:106
  write<uint16_t>(tempSOC, REG_SOC, 2);            // overwrite SOC register with saved value
  DEBUG_PRINT("Restoration complete.");
}

// Change to "Standby" mode, then set parameters for battery model based on datasheet
void STC3115::setParameters() 
 3f4:	ff 92       	push	r15
 3f6:	0f 93       	push	r16
 3f8:	1f 93       	push	r17
 3fa:	cf 93       	push	r28
 3fc:	df 93       	push	r29
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:111
{
  DEBUG_PRINT("Setting parameters...");

  // place in standby mode
  uint8_t tempMode = read<uint8_t>(REG_MODE, 1);
 3fe:	80 e0       	ldi	r24, 0x00	; 0
 400:	bc df       	rcall	.-136    	; 0x37a <unsigned char STC3115::read<unsigned char>(unsigned char, unsigned char) [clone .isra.0] [clone .constprop.17]>
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:112
  tempMode &= ~(1 << 4);    // set GG_RUN (bit index 4) to 0
 402:	68 2f       	mov	r22, r24
 404:	6f 7e       	andi	r22, 0xEF	; 239
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:113
  write<uint8_t>(tempMode, REG_MODE, 1);
 406:	40 e0       	ldi	r20, 0x00	; 0
 408:	80 91 88 00 	lds	r24, 0x0088	; 0x800088 <gauge>
 40c:	6b df       	rcall	.-298    	; 0x2e4 <void STC3115::write<unsigned char>(unsigned char, unsigned char, unsigned char) [clone .isra.1] [clone .constprop.15]>
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:116

  // write model parameters to proper registers (or use default settings if "0")
  if (_rsense && _capacity) {   // if both non-zero
 40e:	80 91 8b 00 	lds	r24, 0x008B	; 0x80008b <gauge+0x3>
 412:	88 23       	and	r24, r24
 414:	a1 f1       	breq	.+104    	; 0x47e <__LOCK_REGION_LENGTH__+0x7e>
 416:	60 91 89 00 	lds	r22, 0x0089	; 0x800089 <gauge+0x1>
 41a:	70 91 8a 00 	lds	r23, 0x008A	; 0x80008a <gauge+0x2>
 41e:	61 15       	cp	r22, r1
 420:	71 05       	cpc	r23, r1
 422:	69 f1       	breq	.+90     	; 0x47e <__LOCK_REGION_LENGTH__+0x7e>
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:120
    DEBUG_PRINT("Overwriting settings for current sensing and control...");

    // configures coulomb counter ADC (register value)
    uint16_t regCC = _rsense * _capacity / 49.556;            
 424:	90 e0       	ldi	r25, 0x00	; 0
 426:	b5 d5       	rcall	.+2922   	; 0xf92 <__mulhi3>
 428:	bc 01       	movw	r22, r24
 42a:	90 e0       	ldi	r25, 0x00	; 0
 42c:	80 e0       	ldi	r24, 0x00	; 0
 42e:	90 d4       	rcall	.+2336   	; 0xd50 <__floatunsisf>
 430:	28 e5       	ldi	r18, 0x58	; 88
 432:	39 e3       	ldi	r19, 0x39	; 57
 434:	46 e4       	ldi	r20, 0x46	; 70
 436:	52 e4       	ldi	r21, 0x42	; 66
 438:	f7 d3       	rcall	.+2030   	; 0xc28 <__divsf3>
 43a:	5e d4       	rcall	.+2236   	; 0xcf8 <__fixunssfsi>
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:121
    write<uint16_t>(regCC, REG_CC_CNF, 2);
 43c:	4f e0       	ldi	r20, 0x0F	; 15
 43e:	80 91 88 00 	lds	r24, 0x0088	; 0x800088 <gauge>
 442:	5c df       	rcall	.-328    	; 0x2fc <void STC3115::write<unsigned int>(unsigned int, unsigned char, unsigned char) [clone .isra.3] [clone .constprop.13]>
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:124

    // configures relaxation current threshold
    uint8_t relaxCurrent = _capacity / 10;                                // current threshold in mA
 444:	80 91 89 00 	lds	r24, 0x0089	; 0x800089 <gauge+0x1>
 448:	90 91 8a 00 	lds	r25, 0x008A	; 0x80008a <gauge+0x2>
 44c:	6a e0       	ldi	r22, 0x0A	; 10
 44e:	70 e0       	ldi	r23, 0x00	; 0
 450:	b1 d5       	rcall	.+2914   	; 0xfb4 <__udivmodhi4>
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:125
    uint8_t regRelaxCurrent = uint8_t (relaxCurrent * _rsense / 47.04);   // convert current threshold to register value
 452:	20 91 8b 00 	lds	r18, 0x008B	; 0x80008b <gauge+0x3>
 456:	30 e0       	ldi	r19, 0x00	; 0
 458:	86 2f       	mov	r24, r22
 45a:	90 e0       	ldi	r25, 0x00	; 0
 45c:	b9 01       	movw	r22, r18
 45e:	99 d5       	rcall	.+2866   	; 0xf92 <__mulhi3>
 460:	bc 01       	movw	r22, r24
 462:	99 0f       	add	r25, r25
 464:	88 0b       	sbc	r24, r24
 466:	99 0b       	sbc	r25, r25
 468:	75 d4       	rcall	.+2282   	; 0xd54 <__floatsisf>
 46a:	26 ef       	ldi	r18, 0xF6	; 246
 46c:	38 e2       	ldi	r19, 0x28	; 40
 46e:	4c e3       	ldi	r20, 0x3C	; 60
 470:	52 e4       	ldi	r21, 0x42	; 66
 472:	da d3       	rcall	.+1972   	; 0xc28 <__divsf3>
 474:	41 d4       	rcall	.+2178   	; 0xcf8 <__fixunssfsi>
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:126
    write<uint8_t>(regRelaxCurrent, REG_CURRENT_THRES, 1);
 476:	45 e1       	ldi	r20, 0x15	; 21
 478:	80 91 88 00 	lds	r24, 0x0088	; 0x800088 <gauge>
 47c:	33 df       	rcall	.-410    	; 0x2e4 <void STC3115::write<unsigned char>(unsigned char, unsigned char, unsigned char) [clone .isra.1] [clone .constprop.15]>
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:129
  }

  if (_resInt && _capacity) {   // if both non-zero
 47e:	80 91 8c 00 	lds	r24, 0x008C	; 0x80008c <gauge+0x4>
 482:	90 91 8d 00 	lds	r25, 0x008D	; 0x80008d <gauge+0x5>
 486:	00 97       	sbiw	r24, 0x00	; 0
 488:	b1 f0       	breq	.+44     	; 0x4b6 <__LOCK_REGION_LENGTH__+0xb6>
 48a:	60 91 89 00 	lds	r22, 0x0089	; 0x800089 <gauge+0x1>
 48e:	70 91 8a 00 	lds	r23, 0x008A	; 0x80008a <gauge+0x2>
 492:	61 15       	cp	r22, r1
 494:	71 05       	cpc	r23, r1
 496:	79 f0       	breq	.+30     	; 0x4b6 <__LOCK_REGION_LENGTH__+0xb6>
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:131
    DEBUG_PRINT("Overwriting settings for voltage estimation algorithm...");
    uint16_t regVM = _resInt * _capacity / 977.78;            // configures voltage estimation algorithm (register value)
 498:	7c d5       	rcall	.+2808   	; 0xf92 <__mulhi3>
 49a:	bc 01       	movw	r22, r24
 49c:	90 e0       	ldi	r25, 0x00	; 0
 49e:	80 e0       	ldi	r24, 0x00	; 0
 4a0:	57 d4       	rcall	.+2222   	; 0xd50 <__floatunsisf>
 4a2:	2c ee       	ldi	r18, 0xEC	; 236
 4a4:	31 e7       	ldi	r19, 0x71	; 113
 4a6:	44 e7       	ldi	r20, 0x74	; 116
 4a8:	54 e4       	ldi	r21, 0x44	; 68
 4aa:	be d3       	rcall	.+1916   	; 0xc28 <__divsf3>
 4ac:	25 d4       	rcall	.+2122   	; 0xcf8 <__fixunssfsi>
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:132
    write<uint16_t>(regVM, REG_VM_CNF, 2);
 4ae:	41 e1       	ldi	r20, 0x11	; 17
 4b0:	80 91 88 00 	lds	r24, 0x0088	; 0x800088 <gauge>
 4b4:	23 df       	rcall	.-442    	; 0x2fc <void STC3115::write<unsigned int>(unsigned int, unsigned char, unsigned char) [clone .isra.3] [clone .constprop.13]>
updateRAM():
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:187
{ // NOTE: class variable _ram[0:15] corresponds to device registers 32-47
  // We can use the starting RAM register REG_RAM to offset indices

  // test word
  uint8_t testWord = 0b10101010;
  write<uint8_t>(testWord, RAM_TEST, 1);
 4b6:	40 e2       	ldi	r20, 0x20	; 32
 4b8:	6a ea       	ldi	r22, 0xAA	; 170
 4ba:	80 91 88 00 	lds	r24, 0x0088	; 0x800088 <gauge>
 4be:	12 df       	rcall	.-476    	; 0x2e4 <void STC3115::write<unsigned char>(unsigned char, unsigned char, unsigned char) [clone .isra.1] [clone .constprop.15]>
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:188
  _ram[RAM_TEST - REG_RAM] = testWord;
 4c0:	8a ea       	ldi	r24, 0xAA	; 170
 4c2:	80 93 8e 00 	sts	0x008E, r24	; 0x80008e <gauge+0x6>
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:191

  // SOC
  uint16_t tempSOC = read<uint16_t>(REG_SOC, 2);
 4c6:	82 e0       	ldi	r24, 0x02	; 2
 4c8:	7c df       	rcall	.-264    	; 0x3c2 <unsigned int STC3115::read<unsigned int>(unsigned char, unsigned char) [clone .isra.2] [clone .constprop.12]>
 4ca:	ec 01       	movw	r28, r24
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:192
  write<uint16_t>(tempSOC, RAM_SOC, 2);
 4cc:	41 e2       	ldi	r20, 0x21	; 33
 4ce:	bc 01       	movw	r22, r24
 4d0:	80 91 88 00 	lds	r24, 0x0088	; 0x800088 <gauge>
 4d4:	13 df       	rcall	.-474    	; 0x2fc <void STC3115::write<unsigned int>(unsigned int, unsigned char, unsigned char) [clone .isra.3] [clone .constprop.13]>
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:193
  _ram[RAM_SOC - REG_RAM] = uint8_t (tempSOC & 0xFF);             // first, lower 8 bits
 4d6:	c0 93 8f 00 	sts	0x008F, r28	; 0x80008f <gauge+0x7>
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:194
  _ram[RAM_SOC - REG_RAM + 1] = uint8_t ((tempSOC >> 8) & 0xFF);  // then, upper 8 bits
 4da:	d0 93 90 00 	sts	0x0090, r29	; 0x800090 <gauge+0x8>
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:197

  // OCV
  uint16_t tempOCV = read<uint16_t>(REG_OCV, 2);
 4de:	8d e0       	ldi	r24, 0x0D	; 13
 4e0:	70 df       	rcall	.-288    	; 0x3c2 <unsigned int STC3115::read<unsigned int>(unsigned char, unsigned char) [clone .isra.2] [clone .constprop.12]>
 4e2:	08 2f       	mov	r16, r24
 4e4:	d9 2f       	mov	r29, r25
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:198
  write<uint16_t>(tempOCV, RAM_OCV, 2);
 4e6:	43 e2       	ldi	r20, 0x23	; 35
 4e8:	68 2f       	mov	r22, r24
 4ea:	79 2f       	mov	r23, r25
 4ec:	80 91 88 00 	lds	r24, 0x0088	; 0x800088 <gauge>
 4f0:	05 df       	rcall	.-502    	; 0x2fc <void STC3115::write<unsigned int>(unsigned int, unsigned char, unsigned char) [clone .isra.3] [clone .constprop.13]>
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:199
  _ram[RAM_OCV - REG_RAM] = uint8_t (tempOCV & 0xFF);             // first, lower 8 bits
 4f2:	00 93 91 00 	sts	0x0091, r16	; 0x800091 <gauge+0x9>
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:200
  _ram[RAM_OCV - REG_RAM + 1] = uint8_t ((tempOCV >> 8) & 0xFF);  // then, upper 8 bits
 4f6:	d0 93 92 00 	sts	0x0092, r29	; 0x800092 <gauge+0xa>
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:203

  // CC_CNF
  uint16_t tempCC = read<uint16_t>(REG_CC_CNF, 2);
 4fa:	8f e0       	ldi	r24, 0x0F	; 15
 4fc:	62 df       	rcall	.-316    	; 0x3c2 <unsigned int STC3115::read<unsigned int>(unsigned char, unsigned char) [clone .isra.2] [clone .constprop.12]>
 4fe:	18 2f       	mov	r17, r24
 500:	d9 2f       	mov	r29, r25
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:204
  write<uint16_t>(tempCC, RAM_CC_CNF, 2);
 502:	45 e2       	ldi	r20, 0x25	; 37
 504:	68 2f       	mov	r22, r24
 506:	79 2f       	mov	r23, r25
 508:	80 91 88 00 	lds	r24, 0x0088	; 0x800088 <gauge>
 50c:	f7 de       	rcall	.-530    	; 0x2fc <void STC3115::write<unsigned int>(unsigned int, unsigned char, unsigned char) [clone .isra.3] [clone .constprop.13]>
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:205
  _ram[RAM_CC_CNF - REG_RAM] = uint8_t (tempCC & 0xFF);             // first, lower 8 bits
 50e:	10 93 93 00 	sts	0x0093, r17	; 0x800093 <gauge+0xb>
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:206
  _ram[RAM_CC_CNF - REG_RAM + 1] = uint8_t ((tempCC >> 8) & 0xFF);  // then, upper 8 bits
 512:	d0 93 94 00 	sts	0x0094, r29	; 0x800094 <gauge+0xc>
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:209

  // VM_CNF
  uint16_t tempVM = read<uint16_t>(REG_VM_CNF, 2);
 516:	81 e1       	ldi	r24, 0x11	; 17
 518:	54 df       	rcall	.-344    	; 0x3c2 <unsigned int STC3115::read<unsigned int>(unsigned char, unsigned char) [clone .isra.2] [clone .constprop.12]>
 51a:	d8 2f       	mov	r29, r24
 51c:	f9 2e       	mov	r15, r25
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:210
  write<uint16_t>(tempVM, RAM_VM_CNF, 2);
 51e:	47 e2       	ldi	r20, 0x27	; 39
 520:	68 2f       	mov	r22, r24
 522:	79 2f       	mov	r23, r25
 524:	80 91 88 00 	lds	r24, 0x0088	; 0x800088 <gauge>
 528:	e9 de       	rcall	.-558    	; 0x2fc <void STC3115::write<unsigned int>(unsigned int, unsigned char, unsigned char) [clone .isra.3] [clone .constprop.13]>
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:211
  _ram[RAM_VM_CNF - REG_RAM] = uint8_t (tempVM & 0xFF);             // first, lower 8 bits
 52a:	d0 93 95 00 	sts	0x0095, r29	; 0x800095 <gauge+0xd>
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:212
  _ram[RAM_VM_CNF - REG_RAM + 1] = uint8_t ((tempVM >> 8) & 0xFF);  // then, upper 8 bits
 52e:	f0 92 96 00 	sts	0x0096, r15	; 0x800096 <gauge+0xe>
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:215

  // checksum
  uint8_t checksum = 0xFF & (testWord + tempSOC + tempOCV + tempCC + tempVM);
 532:	c0 0f       	add	r28, r16
 534:	c6 55       	subi	r28, 0x56	; 86
 536:	c1 0f       	add	r28, r17
 538:	cd 0f       	add	r28, r29
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:216
  write<uint8_t>(checksum, RAM_CHECKSUM, 1);
 53a:	49 e2       	ldi	r20, 0x29	; 41
 53c:	6c 2f       	mov	r22, r28
 53e:	80 91 88 00 	lds	r24, 0x0088	; 0x800088 <gauge>
 542:	d0 de       	rcall	.-608    	; 0x2e4 <void STC3115::write<unsigned char>(unsigned char, unsigned char, unsigned char) [clone .isra.1] [clone .constprop.15]>
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:217
  _ram[RAM_CHECKSUM - REG_RAM] = checksum;
 544:	c0 93 97 00 	sts	0x0097, r28	; 0x800097 <gauge+0xf>
_ZN7STC311513setParametersEv.constprop.10():
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:137
    write<uint16_t>(regVM, REG_VM_CNF, 2);
  }

  // update RAM with new parameters
  updateRAM();
}
 548:	df 91       	pop	r29
 54a:	cf 91       	pop	r28
 54c:	1f 91       	pop	r17
 54e:	0f 91       	pop	r16
 550:	ff 90       	pop	r15
 552:	08 95       	ret

00000554 <STC3115::initialize() [clone .constprop.9]>:
_ZN7STC311510initializeEv.constprop.9():
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:78
    }
  }
}

// Initialize if recovering last known state is not possible
void STC3115::initialize() 
 554:	cf 93       	push	r28
 556:	df 93       	push	r29
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:83
{
  DEBUG_PRINT("Initializing...");
  
  // read OCV register (2 bytes)
  uint16_t tempOCV = read<uint16_t>(REG_OCV, 2);
 558:	8d e0       	ldi	r24, 0x0D	; 13
 55a:	33 df       	rcall	.-410    	; 0x3c2 <unsigned int STC3115::read<unsigned int>(unsigned char, unsigned char) [clone .isra.2] [clone .constprop.12]>
 55c:	ec 01       	movw	r28, r24
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:86

  // set parameters for battery model
  setParameters();
 55e:	4a df       	rcall	.-364    	; 0x3f4 <STC3115::setParameters() [clone .constprop.10]>
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:89

  // restore OCV register with saved value
  write<uint16_t>(tempOCV, REG_OCV, 2);
 560:	4d e0       	ldi	r20, 0x0D	; 13
 562:	be 01       	movw	r22, r28
 564:	80 91 88 00 	lds	r24, 0x0088	; 0x800088 <gauge>
 568:	c9 de       	rcall	.-622    	; 0x2fc <void STC3115::write<unsigned int>(unsigned int, unsigned char, unsigned char) [clone .isra.3] [clone .constprop.13]>
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:90
  delay(200);     // wait for SOC register to be ready
 56a:	68 ec       	ldi	r22, 0xC8	; 200
 56c:	70 e0       	ldi	r23, 0x00	; 0
 56e:	80 e0       	ldi	r24, 0x00	; 0
 570:	90 e0       	ldi	r25, 0x00	; 0
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:93

  DEBUG_PRINT("Initialization complete.");
}
 572:	df 91       	pop	r29
 574:	cf 91       	pop	r28
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:90
  // set parameters for battery model
  setParameters();

  // restore OCV register with saved value
  write<uint16_t>(tempOCV, REG_OCV, 2);
  delay(200);     // wait for SOC register to be ready
 576:	ea cd       	rjmp	.-1068   	; 0x14c <delay>

00000578 <STC3115::startup() [clone .constprop.5]>:
_ZN7STC31157startupEv.constprop.5():
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:26
  _resInt = resInt;         
  //_ram = {0};    // initialize RAM array
}

// Always run on application start-up
void STC3115::startup() 
 578:	0f 93       	push	r16
 57a:	1f 93       	push	r17
 57c:	cf 93       	push	r28
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:31
{
  DEBUG_PRINT("Commencing device startup...");
  
  // Read part ID (1 byte)
  uint8_t partID = read<uint8_t>(REG_ID, 1);
 57e:	88 e1       	ldi	r24, 0x18	; 24
 580:	fc de       	rcall	.-520    	; 0x37a <unsigned char STC3115::read<unsigned char>(unsigned char, unsigned char) [clone .isra.0] [clone .constprop.17]>
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:34

  // Check if part ID matches expected value
  if (partID == 0x14) {
 582:	84 31       	cpi	r24, 0x14	; 20
 584:	79 f5       	brne	.+94     	; 0x5e4 <STC3115::startup() [clone .constprop.5]+0x6c>
 586:	0e e8       	ldi	r16, 0x8E	; 142
 588:	10 e0       	ldi	r17, 0x00	; 0
 58a:	c0 e2       	ldi	r28, 0x20	; 32
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:39

    // Read RAM registers, compare with expected RAM values
    bool needsInit = false;
    for (int i = 0; i < RAM_SIZE; i++) {
      if ( read<uint8_t>(REG_RAM + i, 1) != _ram[i] ) {  
 58c:	8c 2f       	mov	r24, r28
 58e:	f5 de       	rcall	.-534    	; 0x37a <unsigned char STC3115::read<unsigned char>(unsigned char, unsigned char) [clone .isra.0] [clone .constprop.17]>
 590:	f8 01       	movw	r30, r16
 592:	91 91       	ld	r25, Z+
 594:	8f 01       	movw	r16, r30
 596:	89 13       	cpse	r24, r25
 598:	11 c0       	rjmp	.+34     	; 0x5bc <STC3115::startup() [clone .constprop.5]+0x44>
 59a:	cf 5f       	subi	r28, 0xFF	; 255
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:38
  // Check if part ID matches expected value
  if (partID == 0x14) {

    // Read RAM registers, compare with expected RAM values
    bool needsInit = false;
    for (int i = 0; i < RAM_SIZE; i++) {
 59c:	c9 32       	cpi	r28, 0x29	; 41
 59e:	b1 f7       	brne	.-20     	; 0x58c <STC3115::startup() [clone .constprop.5]+0x14>
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:60
      run();
    }

    else {  // RAM is OK, check for loss-of-power events
      DEBUG_PRINT("RAM is OK.");
      uint8_t status = read<uint8_t>(REG_CTRL, 1);
 5a0:	81 e0       	ldi	r24, 0x01	; 1
 5a2:	eb de       	rcall	.-554    	; 0x37a <unsigned char STC3115::read<unsigned char>(unsigned char, unsigned char) [clone .isra.0] [clone .constprop.17]>
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:64
      bool batfail = (status >> 3) & 1;   // 1 if voltage fell below 2.6 V (UVLO)
      bool pordet = (status >> 4) & 1;    // 1 if voltage fell below 2 V (POR threshold)
      
      if (batfail || pordet) {  // battery removal occurred -> initialize
 5a4:	88 71       	andi	r24, 0x18	; 24
 5a6:	c1 f4       	brne	.+48     	; 0x5d8 <STC3115::startup() [clone .constprop.5]+0x60>
restore():
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:99

// Restore to last known battery state using RAM
void STC3115::restore()
{
  DEBUG_PRINT("Restoring to last known battery state...");
  uint16_t tempSOC = read<uint16_t>(RAM_SOC, 2);   // read SOC from RAM
 5a8:	81 e2       	ldi	r24, 0x21	; 33
 5aa:	0b df       	rcall	.-490    	; 0x3c2 <unsigned int STC3115::read<unsigned int>(unsigned char, unsigned char) [clone .isra.2] [clone .constprop.12]>
 5ac:	8c 01       	movw	r16, r24
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:100
  setParameters();                                 // set battery parameters
 5ae:	22 df       	rcall	.-444    	; 0x3f4 <STC3115::setParameters() [clone .constprop.10]>
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:101
  write<uint16_t>(tempSOC, REG_SOC, 2);            // overwrite SOC register with saved value
 5b0:	42 e0       	ldi	r20, 0x02	; 2
 5b2:	b8 01       	movw	r22, r16
 5b4:	80 91 88 00 	lds	r24, 0x0088	; 0x800088 <gauge>
 5b8:	a1 de       	rcall	.-702    	; 0x2fc <void STC3115::write<unsigned int>(unsigned int, unsigned char, unsigned char) [clone .isra.3] [clone .constprop.13]>
 5ba:	0a c0       	rjmp	.+20     	; 0x5d0 <STC3115::startup() [clone .constprop.5]+0x58>
_ZN7STC31157startupEv.constprop.5():
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:39
  if (partID == 0x14) {

    // Read RAM registers, compare with expected RAM values
    bool needsInit = false;
    for (int i = 0; i < RAM_SIZE; i++) {
      if ( read<uint8_t>(REG_RAM + i, 1) != _ram[i] ) {  
 5bc:	c0 e2       	ldi	r28, 0x20	; 32
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:50
    if (needsInit) {  // RAM is not in expected state, reset RAM and initialize
      DEBUG_PRINT("Cannot restore from RAM. Resetting RAM...");

      // reset device RAM first
      for (int i = 0; i < RAM_SIZE; i++) {
          write<uint8_t>(0, REG_RAM + i, 1);
 5be:	4c 2f       	mov	r20, r28
 5c0:	60 e0       	ldi	r22, 0x00	; 0
 5c2:	80 91 88 00 	lds	r24, 0x0088	; 0x800088 <gauge>
 5c6:	8e de       	rcall	.-740    	; 0x2e4 <void STC3115::write<unsigned char>(unsigned char, unsigned char, unsigned char) [clone .isra.1] [clone .constprop.15]>
 5c8:	cf 5f       	subi	r28, 0xFF	; 255
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:49

    if (needsInit) {  // RAM is not in expected state, reset RAM and initialize
      DEBUG_PRINT("Cannot restore from RAM. Resetting RAM...");

      // reset device RAM first
      for (int i = 0; i < RAM_SIZE; i++) {
 5ca:	c9 32       	cpi	r28, 0x29	; 41
 5cc:	c1 f7       	brne	.-16     	; 0x5be <STC3115::startup() [clone .constprop.5]+0x46>
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:67
      bool pordet = (status >> 4) & 1;    // 1 if voltage fell below 2 V (POR threshold)
      
      if (batfail || pordet) {  // battery removal occurred -> initialize
        DEBUG_PRINT("Component lost power in prior operation.");
        write<uint8_t>(0b11, REG_CTRL, 1);  // clear alarm, reset counter
        initialize();   
 5ce:	c2 df       	rcall	.-124    	; 0x554 <STC3115::initialize() [clone .constprop.9]>
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:75
        restore();      // restore to last known state
      }
      run();            // set to run mode
    }
  }
}
 5d0:	cf 91       	pop	r28
 5d2:	1f 91       	pop	r17
 5d4:	0f 91       	pop	r16
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:72
        initialize();   
      }
      else { 
        restore();      // restore to last known state
      }
      run();            // set to run mode
 5d6:	e4 ce       	rjmp	.-568    	; 0x3a0 <STC3115::run() [clone .constprop.7]>
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:66
      bool batfail = (status >> 3) & 1;   // 1 if voltage fell below 2.6 V (UVLO)
      bool pordet = (status >> 4) & 1;    // 1 if voltage fell below 2 V (POR threshold)
      
      if (batfail || pordet) {  // battery removal occurred -> initialize
        DEBUG_PRINT("Component lost power in prior operation.");
        write<uint8_t>(0b11, REG_CTRL, 1);  // clear alarm, reset counter
 5d8:	41 e0       	ldi	r20, 0x01	; 1
 5da:	63 e0       	ldi	r22, 0x03	; 3
 5dc:	80 91 88 00 	lds	r24, 0x0088	; 0x800088 <gauge>
 5e0:	81 de       	rcall	.-766    	; 0x2e4 <void STC3115::write<unsigned char>(unsigned char, unsigned char, unsigned char) [clone .isra.1] [clone .constprop.15]>
 5e2:	f5 cf       	rjmp	.-22     	; 0x5ce <STC3115::startup() [clone .constprop.5]+0x56>
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:75
        restore();      // restore to last known state
      }
      run();            // set to run mode
    }
  }
}
 5e4:	cf 91       	pop	r28
 5e6:	1f 91       	pop	r17
 5e8:	0f 91       	pop	r16
 5ea:	08 95       	ret

000005ec <I2C_ReadRegister>:
I2C_ReadRegister():
/Users/aesters/Documents/Arduino/libraries/vcnl4020-arduino-driver/src/VCNL4020.cpp:201
/*
I2C helper functions: 
All I2C functions read and write values in big-endian format.
*/
uint16_t I2C_ReadRegister(uint8_t dev_address, uint8_t reg_address, uint8_t length)
{ 
 5ec:	df 92       	push	r13
 5ee:	ef 92       	push	r14
 5f0:	ff 92       	push	r15
 5f2:	0f 93       	push	r16
 5f4:	1f 93       	push	r17
 5f6:	cf 93       	push	r28
 5f8:	df 93       	push	r29
 5fa:	d8 2f       	mov	r29, r24
 5fc:	16 2f       	mov	r17, r22
 5fe:	c4 2f       	mov	r28, r20
/Users/aesters/Documents/Arduino/libraries/vcnl4020-arduino-driver/src/VCNL4020.cpp:208
  uint8_t n_bytes_read;     // number of bytes actually read from device
  uint8_t this_byte;
  uint8_t n_bitshifts;

  // start I2C comms with device
  Wire.beginTransmission(dev_address);  
 600:	6c dd       	rcall	.-1320   	; 0xda <TwoWire::beginTransmission(unsigned char) [clone .constprop.38]>
/Users/aesters/Documents/Arduino/libraries/vcnl4020-arduino-driver/src/VCNL4020.cpp:211

  // set target register for reading
  Wire.write(reg_address);
 602:	81 2f       	mov	r24, r17
 604:	37 dd       	rcall	.-1426   	; 0x74 <TwoWire::write(unsigned char) [clone .constprop.39]>
/Users/aesters/Documents/Arduino/libraries/vcnl4020-arduino-driver/src/VCNL4020.cpp:212
  Wire.endTransmission();
 606:	35 de       	rcall	.-918    	; 0x272 <TwoWire::endTransmission() [clone .constprop.40]>
/Users/aesters/Documents/Arduino/libraries/vcnl4020-arduino-driver/src/VCNL4020.cpp:215

  // read contents from registers in big-endian order
  n_bytes_read = Wire.requestFrom(dev_address, length); 
 608:	6c 2f       	mov	r22, r28
 60a:	8d 2f       	mov	r24, r29
 60c:	9a de       	rcall	.-716    	; 0x342 <TwoWire::requestFrom(unsigned char, unsigned char) [clone .constprop.29]>
/Users/aesters/Documents/Arduino/libraries/vcnl4020-arduino-driver/src/VCNL4020.cpp:216
  if (n_bytes_read < length) return 0xFFFF;
 60e:	0f ef       	ldi	r16, 0xFF	; 255
 610:	1f ef       	ldi	r17, 0xFF	; 255
 612:	8c 17       	cp	r24, r28
 614:	e0 f0       	brcs	.+56     	; 0x64e <I2C_ReadRegister+0x62>
 616:	dc 2e       	mov	r13, r28
 618:	dd 0c       	add	r13, r13
 61a:	dd 0c       	add	r13, r13
 61c:	dd 0c       	add	r13, r13
/Users/aesters/Documents/Arduino/libraries/vcnl4020-arduino-driver/src/VCNL4020.cpp:218

  for (int i = 0; i < length; i++) {    
 61e:	f1 2c       	mov	r15, r1
 620:	e1 2c       	mov	r14, r1
/Users/aesters/Documents/Arduino/libraries/vcnl4020-arduino-driver/src/VCNL4020.cpp:202
I2C helper functions: 
All I2C functions read and write values in big-endian format.
*/
uint16_t I2C_ReadRegister(uint8_t dev_address, uint8_t reg_address, uint8_t length)
{ 
  uint16_t reg_value = 0;   // max 2 bytes
 622:	10 e0       	ldi	r17, 0x00	; 0
 624:	00 e0       	ldi	r16, 0x00	; 0
/Users/aesters/Documents/Arduino/libraries/vcnl4020-arduino-driver/src/VCNL4020.cpp:218

  // read contents from registers in big-endian order
  n_bytes_read = Wire.requestFrom(dev_address, length); 
  if (n_bytes_read < length) return 0xFFFF;

  for (int i = 0; i < length; i++) {    
 626:	d0 e0       	ldi	r29, 0x00	; 0
 628:	88 ef       	ldi	r24, 0xF8	; 248
 62a:	d8 0e       	add	r13, r24
 62c:	ec 16       	cp	r14, r28
 62e:	fd 06       	cpc	r15, r29
 630:	74 f4       	brge	.+28     	; 0x64e <I2C_ReadRegister+0x62>
/Users/aesters/Documents/Arduino/libraries/vcnl4020-arduino-driver/src/VCNL4020.cpp:219
    this_byte = Wire.read();
 632:	5e dd       	rcall	.-1348   	; 0xf0 <TwoWire::read() [clone .constprop.32]>
/Users/aesters/Documents/Arduino/libraries/vcnl4020-arduino-driver/src/VCNL4020.cpp:221
    n_bitshifts = 8 * (length - 1 - i);
    reg_value |= uint16_t (this_byte << n_bitshifts);
 634:	99 27       	eor	r25, r25
 636:	0d 2c       	mov	r0, r13
 638:	02 c0       	rjmp	.+4      	; 0x63e <I2C_ReadRegister+0x52>
 63a:	88 0f       	add	r24, r24
 63c:	99 1f       	adc	r25, r25
 63e:	0a 94       	dec	r0
 640:	e2 f7       	brpl	.-8      	; 0x63a <I2C_ReadRegister+0x4e>
 642:	08 2b       	or	r16, r24
 644:	19 2b       	or	r17, r25
/Users/aesters/Documents/Arduino/libraries/vcnl4020-arduino-driver/src/VCNL4020.cpp:218

  // read contents from registers in big-endian order
  n_bytes_read = Wire.requestFrom(dev_address, length); 
  if (n_bytes_read < length) return 0xFFFF;

  for (int i = 0; i < length; i++) {    
 646:	8f ef       	ldi	r24, 0xFF	; 255
 648:	e8 1a       	sub	r14, r24
 64a:	f8 0a       	sbc	r15, r24
 64c:	ed cf       	rjmp	.-38     	; 0x628 <I2C_ReadRegister+0x3c>
/Users/aesters/Documents/Arduino/libraries/vcnl4020-arduino-driver/src/VCNL4020.cpp:225
    n_bitshifts = 8 * (length - 1 - i);
    reg_value |= uint16_t (this_byte << n_bitshifts);
    // device auto-increments register after each read
  }
  return reg_value;
}
 64e:	c8 01       	movw	r24, r16
 650:	df 91       	pop	r29
 652:	cf 91       	pop	r28
 654:	1f 91       	pop	r17
 656:	0f 91       	pop	r16
 658:	ff 90       	pop	r15
 65a:	ef 90       	pop	r14
 65c:	df 90       	pop	r13
 65e:	08 95       	ret

00000660 <VCNL4020_IsConnected.constprop.28>:
VCNL4020_IsConnected.constprop.28():
/Users/aesters/Documents/Arduino/libraries/vcnl4020-arduino-driver/src/VCNL4020.cpp:41
bool VCNL4020_IsConnected(VCNL4020 *pDevice) 
{
    uint8_t id = 0;

    // Product ID/revision register should return 0x21
    id = (uint8_t) I2C_ReadRegister(pDevice->address, REG_ID, 1);
 660:	41 e0       	ldi	r20, 0x01	; 1
 662:	61 e8       	ldi	r22, 0x81	; 129
 664:	80 91 98 00 	lds	r24, 0x0098	; 0x800098 <prox_sensor>
 668:	c1 df       	rcall	.-126    	; 0x5ec <I2C_ReadRegister>
/Users/aesters/Documents/Arduino/libraries/vcnl4020-arduino-driver/src/VCNL4020.cpp:42
    return (id == 0x21); 
 66a:	91 e0       	ldi	r25, 0x01	; 1
 66c:	81 32       	cpi	r24, 0x21	; 33
 66e:	09 f0       	breq	.+2      	; 0x672 <VCNL4020_IsConnected.constprop.28+0x12>
 670:	90 e0       	ldi	r25, 0x00	; 0
/Users/aesters/Documents/Arduino/libraries/vcnl4020-arduino-driver/src/VCNL4020.cpp:43
}
 672:	89 2f       	mov	r24, r25
 674:	08 95       	ret

00000676 <VCNL4020_ClearInterrupts.constprop.21>:
VCNL4020_ClearInterrupts.constprop.21():
/Users/aesters/Documents/Arduino/libraries/vcnl4020-arduino-driver/src/VCNL4020.cpp:185
}

VCNL4020_Status VCNL4020_ClearInterrupts(VCNL4020 *pDevice) 
{
    // Check for connection
    pDevice->connected = VCNL4020_IsConnected(pDevice);
 676:	f4 df       	rcall	.-24     	; 0x660 <VCNL4020_IsConnected.constprop.28>
 678:	80 93 9c 00 	sts	0x009C, r24	; 0x80009c <prox_sensor+0x4>
/Users/aesters/Documents/Arduino/libraries/vcnl4020-arduino-driver/src/VCNL4020.cpp:186
    if (!pDevice->connected) {
 67c:	88 23       	and	r24, r24
 67e:	41 f0       	breq	.+16     	; 0x690 <VCNL4020_ClearInterrupts.constprop.21+0x1a>
/Users/aesters/Documents/Arduino/libraries/vcnl4020-arduino-driver/src/VCNL4020.cpp:191
        return STATUS_CONNECTION_ERROR; 
    }

    // Write 0b1111 to clear all interrupt flags
    I2C_WriteRegister(pDevice->address, REG_INT_STATUS, 1, 0x0F);
 680:	4f e0       	ldi	r20, 0x0F	; 15
 682:	50 e0       	ldi	r21, 0x00	; 0
 684:	6e e8       	ldi	r22, 0x8E	; 142
 686:	80 91 98 00 	lds	r24, 0x0098	; 0x800098 <prox_sensor>
 68a:	20 de       	rcall	.-960    	; 0x2cc <I2C_WriteRegister.constprop.35>
 68c:	80 e0       	ldi	r24, 0x00	; 0
 68e:	08 95       	ret
/Users/aesters/Documents/Arduino/libraries/vcnl4020-arduino-driver/src/VCNL4020.cpp:187
VCNL4020_Status VCNL4020_ClearInterrupts(VCNL4020 *pDevice) 
{
    // Check for connection
    pDevice->connected = VCNL4020_IsConnected(pDevice);
    if (!pDevice->connected) {
        return STATUS_CONNECTION_ERROR; 
 690:	81 e0       	ldi	r24, 0x01	; 1
/Users/aesters/Documents/Arduino/libraries/vcnl4020-arduino-driver/src/VCNL4020.cpp:194

    // Write 0b1111 to clear all interrupt flags
    I2C_WriteRegister(pDevice->address, REG_INT_STATUS, 1, 0x0F);

    return STATUS_OK;
}
 692:	08 95       	ret

00000694 <VCNL4020_ReadProximity.constprop.19>:
VCNL4020_ReadProximity.constprop.19():
/Users/aesters/Documents/Arduino/libraries/vcnl4020-arduino-driver/src/VCNL4020.cpp:128
    I2C_WriteRegister(pDevice->address, REG_PROX_RATE, 1, rate);

    return STATUS_OK;
}

uint16_t VCNL4020_ReadProximity(VCNL4020 *pDevice) 
 694:	cf 93       	push	r28
 696:	df 93       	push	r29
/Users/aesters/Documents/Arduino/libraries/vcnl4020-arduino-driver/src/VCNL4020.cpp:138
    */
    uint16_t reg_value = 0;
    VCNL4020_Status status;

    // Check for connection
    pDevice->connected = VCNL4020_IsConnected(pDevice);
 698:	e3 df       	rcall	.-58     	; 0x660 <VCNL4020_IsConnected.constprop.28>
 69a:	80 93 9c 00 	sts	0x009C, r24	; 0x80009c <prox_sensor+0x4>
/Users/aesters/Documents/Arduino/libraries/vcnl4020-arduino-driver/src/VCNL4020.cpp:140
    if (!pDevice->connected) {
        return (uint16_t) STATUS_CONNECTION_ERROR; 
 69e:	c1 e0       	ldi	r28, 0x01	; 1
 6a0:	d0 e0       	ldi	r29, 0x00	; 0
/Users/aesters/Documents/Arduino/libraries/vcnl4020-arduino-driver/src/VCNL4020.cpp:139
    uint16_t reg_value = 0;
    VCNL4020_Status status;

    // Check for connection
    pDevice->connected = VCNL4020_IsConnected(pDevice);
    if (!pDevice->connected) {
 6a2:	88 23       	and	r24, r24
 6a4:	01 f1       	breq	.+64     	; 0x6e6 <VCNL4020_ReadProximity.constprop.19+0x52>
/Users/aesters/Documents/Arduino/libraries/vcnl4020-arduino-driver/src/VCNL4020.cpp:144
        return (uint16_t) STATUS_CONNECTION_ERROR; 
    }

    // In MANUAL mode, trigger a single measurement
    if (pDevice->mode == MANUAL) {
 6a6:	80 91 9a 00 	lds	r24, 0x009A	; 0x80009a <prox_sensor+0x2>
 6aa:	81 11       	cpse	r24, r1
 6ac:	20 c0       	rjmp	.+64     	; 0x6ee <VCNL4020_ReadProximity.constprop.19+0x5a>
 6ae:	c0 91 98 00 	lds	r28, 0x0098	; 0x800098 <prox_sensor>
I2C_SetBit():
/Users/aesters/Documents/Arduino/libraries/vcnl4020-arduino-driver/src/VCNL4020.cpp:253
void I2C_SetBit(uint8_t dev_address, uint8_t reg_address, uint8_t bit_pos, bool set_clear)
{
    uint8_t reg_value = 0;

    // Read current register value
    reg_value = I2C_ReadRegister(dev_address, reg_address, 1);
 6b2:	41 e0       	ldi	r20, 0x01	; 1
 6b4:	60 e8       	ldi	r22, 0x80	; 128
 6b6:	8c 2f       	mov	r24, r28
 6b8:	99 df       	rcall	.-206    	; 0x5ec <I2C_ReadRegister>
/Users/aesters/Documents/Arduino/libraries/vcnl4020-arduino-driver/src/VCNL4020.cpp:257

    // Modify bit
    if (set_clear)  // Set 
        reg_value |= (1 << bit_pos);   
 6ba:	88 60       	ori	r24, 0x08	; 8
/Users/aesters/Documents/Arduino/libraries/vcnl4020-arduino-driver/src/VCNL4020.cpp:262
    else            // Clear 
        reg_value &= ~(1 << bit_pos);  

    // Update register value 
    I2C_WriteRegister(dev_address, reg_address, 1, reg_value);
 6bc:	48 2f       	mov	r20, r24
 6be:	50 e0       	ldi	r21, 0x00	; 0
 6c0:	60 e8       	ldi	r22, 0x80	; 128
 6c2:	8c 2f       	mov	r24, r28
 6c4:	03 de       	rcall	.-1018   	; 0x2cc <I2C_WriteRegister.constprop.35>
VCNL4020_ReadProximity.constprop.19():
/Users/aesters/Documents/Arduino/libraries/vcnl4020-arduino-driver/src/VCNL4020.cpp:146
    }

    // In MANUAL mode, trigger a single measurement
    if (pDevice->mode == MANUAL) {
        I2C_SetBit(pDevice->address, REG_COMMAND, 3, true);  // Set bit 3
        delay(10);
 6c6:	6a e0       	ldi	r22, 0x0A	; 10
 6c8:	70 e0       	ldi	r23, 0x00	; 0
 6ca:	80 e0       	ldi	r24, 0x00	; 0
 6cc:	90 e0       	ldi	r25, 0x00	; 0
 6ce:	3e dd       	rcall	.-1412   	; 0x14c <delay>
/Users/aesters/Documents/Arduino/libraries/vcnl4020-arduino-driver/src/VCNL4020.cpp:157
            status_reg = (uint8_t) I2C_ReadRegister(pDevice->address, REG_COMMAND, 1);
        } while ((status_reg & (1 << 5)) == 0); // Wait until bit 6 is set
    }

    // Read proximity data from the sensor
    reg_value = I2C_ReadRegister(pDevice->address, REG_PROX_RESULT, 2);
 6d0:	42 e0       	ldi	r20, 0x02	; 2
 6d2:	67 e8       	ldi	r22, 0x87	; 135
 6d4:	80 91 98 00 	lds	r24, 0x0098	; 0x800098 <prox_sensor>
 6d8:	89 df       	rcall	.-238    	; 0x5ec <I2C_ReadRegister>
 6da:	ec 01       	movw	r28, r24
/Users/aesters/Documents/Arduino/libraries/vcnl4020-arduino-driver/src/VCNL4020.cpp:160

    // Clear interrupt flags
    status = VCNL4020_ClearInterrupts(pDevice);
 6dc:	cc df       	rcall	.-104    	; 0x676 <VCNL4020_ClearInterrupts.constprop.21>
/Users/aesters/Documents/Arduino/libraries/vcnl4020-arduino-driver/src/VCNL4020.cpp:161
    if (status != STATUS_OK) {
 6de:	88 23       	and	r24, r24
 6e0:	11 f0       	breq	.+4      	; 0x6e6 <VCNL4020_ReadProximity.constprop.19+0x52>
/Users/aesters/Documents/Arduino/libraries/vcnl4020-arduino-driver/src/VCNL4020.cpp:162
        return (uint16_t) status; 
 6e2:	c8 2f       	mov	r28, r24
 6e4:	d0 e0       	ldi	r29, 0x00	; 0
/Users/aesters/Documents/Arduino/libraries/vcnl4020-arduino-driver/src/VCNL4020.cpp:166
    }

    return reg_value; 
}
 6e6:	ce 01       	movw	r24, r28
 6e8:	df 91       	pop	r29
 6ea:	cf 91       	pop	r28
 6ec:	08 95       	ret
/Users/aesters/Documents/Arduino/libraries/vcnl4020-arduino-driver/src/VCNL4020.cpp:152
    }
    else {
        // In AUTO modes, wait for data ready
        uint8_t status_reg = 0;
        do {
            status_reg = (uint8_t) I2C_ReadRegister(pDevice->address, REG_COMMAND, 1);
 6ee:	41 e0       	ldi	r20, 0x01	; 1
 6f0:	60 e8       	ldi	r22, 0x80	; 128
 6f2:	80 91 98 00 	lds	r24, 0x0098	; 0x800098 <prox_sensor>
 6f6:	7a df       	rcall	.-268    	; 0x5ec <I2C_ReadRegister>
/Users/aesters/Documents/Arduino/libraries/vcnl4020-arduino-driver/src/VCNL4020.cpp:153
        } while ((status_reg & (1 << 5)) == 0); // Wait until bit 6 is set
 6f8:	85 ff       	sbrs	r24, 5
 6fa:	f9 cf       	rjmp	.-14     	; 0x6ee <VCNL4020_ReadProximity.constprop.19+0x5a>
 6fc:	e9 cf       	rjmp	.-46     	; 0x6d0 <VCNL4020_ReadProximity.constprop.19+0x3c>

000006fe <digitalRead.constprop.2>:
digitalRead.constprop.2():
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:180
  // "read" should *NEVER* change the behavior of the thing you're using it on.
  // That's why it's called "read" not "write". As an added bonus, sets the
  // stage for auto-fast-digitalRead() for compile time known pins.
  // if (timer != NOT_ON_TIMER) turnOffPWM(timer);

  if (*portInputRegister(port) & bit) return HIGH;
 6fe:	86 b3       	in	r24, 0x16	; 22
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:182
  return LOW;
}
 700:	83 fb       	bst	r24, 3
 702:	88 27       	eor	r24, r24
 704:	80 f9       	bld	r24, 0
 706:	90 e0       	ldi	r25, 0x00	; 0
 708:	08 95       	ret

0000070a <digitalWrite>:
digitalWrite():
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:139
}

void digitalWrite(uint8_t pin, uint8_t val)
{
  if (pin&128) {pin=analogInputToDigitalPin((pin&127));}
  uint8_t timer = digitalPinToTimer(pin);
 70a:	90 e0       	ldi	r25, 0x00	; 0
 70c:	fc 01       	movw	r30, r24
 70e:	e6 5d       	subi	r30, 0xD6	; 214
 710:	ff 4f       	sbci	r31, 0xFF	; 255
 712:	34 91       	lpm	r19, Z
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:140
  uint8_t bit = digitalPinToBitMask(pin);
 714:	fc 01       	movw	r30, r24
 716:	ea 5c       	subi	r30, 0xCA	; 202
 718:	ff 4f       	sbci	r31, 0xFF	; 255
 71a:	24 91       	lpm	r18, Z
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:141
  uint8_t port = digitalPinToPort(pin);
 71c:	fc 01       	movw	r30, r24
 71e:	e0 5d       	subi	r30, 0xD0	; 208
 720:	ff 4f       	sbci	r31, 0xFF	; 255
 722:	e4 91       	lpm	r30, Z
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:144
  volatile uint8_t *out;

  if (port == NOT_A_PIN) return;
 724:	ee 23       	and	r30, r30
 726:	b9 f0       	breq	.+46     	; 0x756 <digitalWrite+0x4c>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:148

  // If the pin that support PWM output, we need to turn it off
  // before doing a digital write.
  if (timer != NOT_ON_TIMER) turnOffPWM(timer);
 728:	33 23       	and	r19, r19
 72a:	29 f0       	breq	.+10     	; 0x736 <digitalWrite+0x2c>
turnOffPWM():
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:67
}

static void turnOffPWM(uint8_t timer)
{
  #if defined(TCCR0A) && defined(COM0A1)
    if( timer == TIMER0A){
 72c:	31 30       	cpi	r19, 0x01	; 1
 72e:	a1 f4       	brne	.+40     	; 0x758 <digitalWrite+0x4e>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:68
      cbi(TCCR0A, COM0A1);
 730:	8a b5       	in	r24, 0x2a	; 42
 732:	8f 77       	andi	r24, 0x7F	; 127
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:74
      //cbi(TCCR0A, COM0A0);
    } else
  #endif
  #if defined(TCCR0A) && defined(COM0B1)
    if( timer == TIMER0B){
      cbi(TCCR0A, COM0B1);
 734:	8a bd       	out	0x2a, r24	; 42
digitalWrite():
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:150

  // If the pin that support PWM output, we need to turn it off
  // before doing a digital write.
  if (timer != NOT_ON_TIMER) turnOffPWM(timer);

  out = portOutputRegister(port);
 736:	f0 e0       	ldi	r31, 0x00	; 0
 738:	ee 0f       	add	r30, r30
 73a:	ff 1f       	adc	r31, r31
 73c:	ec 5d       	subi	r30, 0xDC	; 220
 73e:	ff 4f       	sbci	r31, 0xFF	; 255
 740:	a5 91       	lpm	r26, Z+
 742:	b4 91       	lpm	r27, Z
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:153

  if (val == LOW) {
    uint8_t oldSREG = SREG;
 744:	8f b7       	in	r24, 0x3f	; 63
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:152
  // before doing a digital write.
  if (timer != NOT_ON_TIMER) turnOffPWM(timer);

  out = portOutputRegister(port);

  if (val == LOW) {
 746:	61 11       	cpse	r22, r1
 748:	18 c0       	rjmp	.+48     	; 0x77a <digitalWrite+0x70>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:154
    uint8_t oldSREG = SREG;
    cli();
 74a:	f8 94       	cli
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:155
    *out &= ~bit;
 74c:	ec 91       	ld	r30, X
 74e:	20 95       	com	r18
 750:	2e 23       	and	r18, r30
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:160
    SREG = oldSREG;
  } else {
    uint8_t oldSREG = SREG;
    cli();
    *out |= bit;
 752:	2c 93       	st	X, r18
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:161
    SREG = oldSREG;
 754:	8f bf       	out	0x3f, r24	; 63
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:163
  }
}
 756:	08 95       	ret
turnOffPWM():
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:73
      cbi(TCCR0A, COM0A1);
      //cbi(TCCR0A, COM0A0);
    } else
  #endif
  #if defined(TCCR0A) && defined(COM0B1)
    if( timer == TIMER0B){
 758:	32 30       	cpi	r19, 0x02	; 2
 75a:	19 f4       	brne	.+6      	; 0x762 <digitalWrite+0x58>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:74
      cbi(TCCR0A, COM0B1);
 75c:	8a b5       	in	r24, 0x2a	; 42
 75e:	8f 7d       	andi	r24, 0xDF	; 223
 760:	e9 cf       	rjmp	.-46     	; 0x734 <digitalWrite+0x2a>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:106
      //cbi(TCCR1C,COM1D0);
    } else
  #else
    // Timer1 for non-x61/x7
    #if defined(TCCR1) && defined(COM1A1) // x5
      if(timer == TIMER1A){
 762:	33 30       	cpi	r19, 0x03	; 3
 764:	21 f4       	brne	.+8      	; 0x76e <digitalWrite+0x64>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:107
        TCCR1 &= ~(1<<COM1A1);
 766:	80 b7       	in	r24, 0x30	; 48
 768:	8f 7d       	andi	r24, 0xDF	; 223
 76a:	80 bf       	out	0x30, r24	; 48
 76c:	e4 cf       	rjmp	.-56     	; 0x736 <digitalWrite+0x2c>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:112
        //cbi(TCCR1, COM1A0);
      } else
    #endif
    #if defined(TCCR1) && defined(COM1B1) // x5
      if( timer == TIMER1B){
 76e:	34 30       	cpi	r19, 0x04	; 4
 770:	11 f7       	brne	.-60     	; 0x736 <digitalWrite+0x2c>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:113
        GTCCR &= ~(1<<COM1B1);
 772:	8c b5       	in	r24, 0x2c	; 44
 774:	8f 7d       	andi	r24, 0xDF	; 223
 776:	8c bd       	out	0x2c, r24	; 44
 778:	de cf       	rjmp	.-68     	; 0x736 <digitalWrite+0x2c>
digitalWrite():
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:159
    cli();
    *out &= ~bit;
    SREG = oldSREG;
  } else {
    uint8_t oldSREG = SREG;
    cli();
 77a:	f8 94       	cli
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:160
    *out |= bit;
 77c:	ec 91       	ld	r30, X
 77e:	2e 2b       	or	r18, r30
 780:	e8 cf       	rjmp	.-48     	; 0x752 <digitalWrite+0x48>

00000782 <pinMode>:
pinMode():
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:33
#define ARDUINO_MAIN
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
 782:	cf 93       	push	r28
 784:	df 93       	push	r29
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:35
  if (pin&128) {pin=analogInputToDigitalPin((pin&127));}
  uint8_t bit = digitalPinToBitMask(pin);
 786:	90 e0       	ldi	r25, 0x00	; 0
 788:	fc 01       	movw	r30, r24
 78a:	ea 5c       	subi	r30, 0xCA	; 202
 78c:	ff 4f       	sbci	r31, 0xFF	; 255
 78e:	24 91       	lpm	r18, Z
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:36
  uint8_t port = digitalPinToPort(pin);
 790:	80 5d       	subi	r24, 0xD0	; 208
 792:	9f 4f       	sbci	r25, 0xFF	; 255
 794:	fc 01       	movw	r30, r24
 796:	84 91       	lpm	r24, Z
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:39
  volatile uint8_t *reg, *out;

  if (port == NOT_A_PIN) return;
 798:	88 23       	and	r24, r24
 79a:	c9 f0       	breq	.+50     	; 0x7ce <pinMode+0x4c>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:41

  reg = portModeRegister(port);
 79c:	90 e0       	ldi	r25, 0x00	; 0
 79e:	88 0f       	add	r24, r24
 7a0:	99 1f       	adc	r25, r25
 7a2:	fc 01       	movw	r30, r24
 7a4:	e2 5e       	subi	r30, 0xE2	; 226
 7a6:	ff 4f       	sbci	r31, 0xFF	; 255
 7a8:	a5 91       	lpm	r26, Z+
 7aa:	b4 91       	lpm	r27, Z
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:42
  out = portOutputRegister(port);
 7ac:	fc 01       	movw	r30, r24
 7ae:	ec 5d       	subi	r30, 0xDC	; 220
 7b0:	ff 4f       	sbci	r31, 0xFF	; 255
 7b2:	c5 91       	lpm	r28, Z+
 7b4:	d4 91       	lpm	r29, Z
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:44

  if (mode == INPUT) {
 7b6:	61 11       	cpse	r22, r1
 7b8:	0d c0       	rjmp	.+26     	; 0x7d4 <pinMode+0x52>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:45
    uint8_t oldSREG = SREG;
 7ba:	9f b7       	in	r25, 0x3f	; 63
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:46
                cli();
 7bc:	f8 94       	cli
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:47
    *reg &= ~bit;
 7be:	8c 91       	ld	r24, X
 7c0:	20 95       	com	r18
 7c2:	82 23       	and	r24, r18
 7c4:	8c 93       	st	X, r24
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:48
    *out &= ~bit;
 7c6:	88 81       	ld	r24, Y
 7c8:	28 23       	and	r18, r24
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:54
    SREG = oldSREG;
  } else if (mode == INPUT_PULLUP) {
    uint8_t oldSREG = SREG;
                cli();
    *reg &= ~bit;
    *out |= bit;
 7ca:	28 83       	st	Y, r18
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:55
    SREG = oldSREG;
 7cc:	9f bf       	out	0x3f, r25	; 63
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:62
    uint8_t oldSREG = SREG;
                cli();
    *reg |= bit;
    SREG = oldSREG;
  }
}
 7ce:	df 91       	pop	r29
 7d0:	cf 91       	pop	r28
 7d2:	08 95       	ret
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:50
    uint8_t oldSREG = SREG;
                cli();
    *reg &= ~bit;
    *out &= ~bit;
    SREG = oldSREG;
  } else if (mode == INPUT_PULLUP) {
 7d4:	62 30       	cpi	r22, 0x02	; 2
 7d6:	51 f4       	brne	.+20     	; 0x7ec <pinMode+0x6a>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:51
    uint8_t oldSREG = SREG;
 7d8:	9f b7       	in	r25, 0x3f	; 63
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:52
                cli();
 7da:	f8 94       	cli
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:53
    *reg &= ~bit;
 7dc:	3c 91       	ld	r19, X
 7de:	82 2f       	mov	r24, r18
 7e0:	80 95       	com	r24
 7e2:	83 23       	and	r24, r19
 7e4:	8c 93       	st	X, r24
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:54
    *out |= bit;
 7e6:	e8 81       	ld	r30, Y
 7e8:	2e 2b       	or	r18, r30
 7ea:	ef cf       	rjmp	.-34     	; 0x7ca <pinMode+0x48>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:57
    SREG = oldSREG;
  } else {
    uint8_t oldSREG = SREG;
 7ec:	8f b7       	in	r24, 0x3f	; 63
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:58
                cli();
 7ee:	f8 94       	cli
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:59
    *reg |= bit;
 7f0:	ec 91       	ld	r30, X
 7f2:	2e 2b       	or	r18, r30
 7f4:	2c 93       	st	X, r18
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring_digital.c:60
    SREG = oldSREG;
 7f6:	8f bf       	out	0x3f, r24	; 63
 7f8:	ea cf       	rjmp	.-44     	; 0x7ce <pinMode+0x4c>

000007fa <__vector_14>:
__vector_14():
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Slave/USI_TWI_Slave.c:207
/*----------------------------------------------------------
 Handles all the communication. Is disabled only when waiting
 for new Start Condition.
----------------------------------------------------------*/
ISR(USI_OVERFLOW_VECTOR)
{
 7fa:	1f 92       	push	r1
 7fc:	0f 92       	push	r0
 7fe:	0f b6       	in	r0, 0x3f	; 63
 800:	0f 92       	push	r0
 802:	11 24       	eor	r1, r1
 804:	2f 93       	push	r18
 806:	8f 93       	push	r24
 808:	9f 93       	push	r25
 80a:	ef 93       	push	r30
 80c:	ff 93       	push	r31
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Slave/USI_TWI_Slave.c:212
  unsigned char tmpRxHead;
  unsigned char tmpTxTail; // Temporary variables to store volatiles
  unsigned char tmpUSIDR;

  switch (USI_TWI_Overflow_State) {
 80e:	80 91 81 00 	lds	r24, 0x0081	; 0x800081 <USI_TWI_Overflow_State>
 812:	82 30       	cpi	r24, 0x02	; 2
 814:	09 f4       	brne	.+2      	; 0x818 <__vector_14+0x1e>
 816:	5e c0       	rjmp	.+188    	; 0x8d4 <__vector_14+0xda>
 818:	78 f4       	brcc	.+30     	; 0x838 <__vector_14+0x3e>
 81a:	88 23       	and	r24, r24
 81c:	49 f1       	breq	.+82     	; 0x870 <__vector_14+0x76>
 81e:	81 30       	cpi	r24, 0x01	; 1
 820:	09 f4       	brne	.+2      	; 0x824 <__vector_14+0x2a>
 822:	3e c0       	rjmp	.+124    	; 0x8a0 <__vector_14+0xa6>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Slave/USI_TWI_Slave.c:306
    {
      SET_USI_TO_SEND_NACK();
    }
    break;
  }
}
 824:	ff 91       	pop	r31
 826:	ef 91       	pop	r30
 828:	9f 91       	pop	r25
 82a:	8f 91       	pop	r24
 82c:	2f 91       	pop	r18
 82e:	0f 90       	pop	r0
 830:	0f be       	out	0x3f, r0	; 63
 832:	0f 90       	pop	r0
 834:	1f 90       	pop	r1
 836:	18 95       	reti
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Slave/USI_TWI_Slave.c:212
{
  unsigned char tmpRxHead;
  unsigned char tmpTxTail; // Temporary variables to store volatiles
  unsigned char tmpUSIDR;

  switch (USI_TWI_Overflow_State) {
 838:	84 30       	cpi	r24, 0x04	; 4
 83a:	09 f4       	brne	.+2      	; 0x83e <__vector_14+0x44>
 83c:	51 c0       	rjmp	.+162    	; 0x8e0 <__vector_14+0xe6>
 83e:	48 f1       	brcs	.+82     	; 0x892 <__vector_14+0x98>
 840:	85 30       	cpi	r24, 0x05	; 5
 842:	81 f7       	brne	.-32     	; 0x824 <__vector_14+0x2a>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Slave/USI_TWI_Slave.c:293
    break;

  // Copy data from USIDR and send ACK. Next USI_SLAVE_REQUEST_DATA
  case USI_SLAVE_GET_DATA_AND_SEND_ACK:
    // Put data into Buffer
    USI_TWI_Overflow_State = USI_SLAVE_REQUEST_DATA;
 844:	84 e0       	ldi	r24, 0x04	; 4
 846:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <USI_TWI_Overflow_State>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Slave/USI_TWI_Slave.c:294
    tmpUSIDR              = USIDR; // Not necessary, but prevents warnings
 84a:	9f b1       	in	r25, 0x0f	; 15
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Slave/USI_TWI_Slave.c:295
    tmpRxHead = (TWI_RxHead + 1) & TWI_RX_BUFFER_MASK;
 84c:	80 91 9d 00 	lds	r24, 0x009D	; 0x80009d <TWI_RxHead>
 850:	8f 5f       	subi	r24, 0xFF	; 255
 852:	8f 70       	andi	r24, 0x0F	; 15
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Slave/USI_TWI_Slave.c:296
    if (TWI_RxTail != tmpRxHead) {
 854:	20 91 9e 00 	lds	r18, 0x009E	; 0x80009e <TWI_RxTail>
 858:	28 17       	cp	r18, r24
 85a:	09 f4       	brne	.+2      	; 0x85e <__vector_14+0x64>
 85c:	46 c0       	rjmp	.+140    	; 0x8ea <__vector_14+0xf0>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Slave/USI_TWI_Slave.c:297
      TWI_RxHead            = tmpRxHead;
 85e:	80 93 9d 00 	sts	0x009D, r24	; 0x80009d <TWI_RxHead>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Slave/USI_TWI_Slave.c:298
      TWI_RxBuf[TWI_RxHead] = tmpUSIDR;
 862:	e0 91 9d 00 	lds	r30, 0x009D	; 0x80009d <TWI_RxHead>
 866:	f0 e0       	ldi	r31, 0x00	; 0
 868:	e0 5a       	subi	r30, 0xA0	; 160
 86a:	ff 4f       	sbci	r31, 0xFF	; 255
 86c:	90 83       	st	Z, r25
 86e:	0b c0       	rjmp	.+22     	; 0x886 <__vector_14+0x8c>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Slave/USI_TWI_Slave.c:216

  switch (USI_TWI_Overflow_State) {
  // ---------- Address mode ----------
  // Check address and send ACK (and next USI_SLAVE_SEND_DATA) if OK, else reset USI.
  case USI_SLAVE_CHECK_ADDRESS:
    if ((USIDR == 0) || ((USIDR >> 1) == TWI_slaveAddress)) {
 870:	8f b1       	in	r24, 0x0f	; 15
 872:	88 23       	and	r24, r24
 874:	19 f0       	breq	.+6      	; 0x87c <__vector_14+0x82>
 876:	8f b1       	in	r24, 0x0f	; 15
 878:	86 95       	lsr	r24
 87a:	71 f4       	brne	.+28     	; 0x898 <__vector_14+0x9e>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Slave/USI_TWI_Slave.c:217
      if (USIDR & 0x01) {
 87c:	78 9b       	sbis	0x0f, 0	; 15
 87e:	07 c0       	rjmp	.+14     	; 0x88e <__vector_14+0x94>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Slave/USI_TWI_Slave.c:224
          // reset tx buffer and call callback
          tmpTxTail = TWI_TxHead;
          TWI_TxTail = tmpTxTail;
          USI_TWI_On_Slave_Transmit();
        }
        USI_TWI_Overflow_State = USI_SLAVE_SEND_DATA;
 880:	81 e0       	ldi	r24, 0x01	; 1
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Slave/USI_TWI_Slave.c:226
      } else {
        USI_TWI_Overflow_State = USI_SLAVE_REQUEST_DATA;
 882:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <USI_TWI_Overflow_State>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Slave/USI_TWI_Slave.c:228
      }
      SET_USI_TO_SEND_ACK();
 886:	1f b8       	out	0x0f, r1	; 15
 888:	b8 9a       	sbi	0x17, 0	; 23
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Slave/USI_TWI_Slave.c:302
      TWI_RxHead            = tmpRxHead;
      TWI_RxBuf[TWI_RxHead] = tmpUSIDR;
      SET_USI_TO_SEND_ACK();
    } else // If the buffer is full then:
    {
      SET_USI_TO_SEND_NACK();
 88a:	8e e7       	ldi	r24, 0x7E	; 126
 88c:	21 c0       	rjmp	.+66     	; 0x8d0 <__vector_14+0xd6>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Slave/USI_TWI_Slave.c:226
          TWI_TxTail = tmpTxTail;
          USI_TWI_On_Slave_Transmit();
        }
        USI_TWI_Overflow_State = USI_SLAVE_SEND_DATA;
      } else {
        USI_TWI_Overflow_State = USI_SLAVE_REQUEST_DATA;
 88e:	84 e0       	ldi	r24, 0x04	; 4
 890:	f8 cf       	rjmp	.-16     	; 0x882 <__vector_14+0x88>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Slave/USI_TWI_Slave.c:237
    break;

  // ----- Master write data mode ------
  // Check reply and goto USI_SLAVE_SEND_DATA if OK, else reset USI.
  case USI_SLAVE_CHECK_REPLY_FROM_SEND_DATA:
    if (USIDR) // If NACK, the master does not want more data.
 892:	8f b1       	in	r24, 0x0f	; 15
 894:	88 23       	and	r24, r24
 896:	21 f0       	breq	.+8      	; 0x8a0 <__vector_14+0xa6>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Slave/USI_TWI_Slave.c:255
    if (TWI_TxHead != tmpTxTail) {
      TWI_TxTail = (TWI_TxTail + 1) & TWI_TX_BUFFER_MASK;
      USIDR      = TWI_TxBuf[TWI_TxTail];
    } else // If the buffer is empty then:
    {
      SET_USI_TO_TWI_START_CONDITION_MODE();
 898:	b8 98       	cbi	0x17, 0	; 23
 89a:	88 ea       	ldi	r24, 0xA8	; 168
 89c:	8d b9       	out	0x0d, r24	; 13
 89e:	17 c0       	rjmp	.+46     	; 0x8ce <__vector_14+0xd4>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Slave/USI_TWI_Slave.c:249
  // Copy data from buffer to USIDR and set USI to shift byte. Next USI_SLAVE_REQUEST_REPLY_FROM_SEND_DATA
  /* Falls through. */
  case USI_SLAVE_SEND_DATA:

    // Get data from Buffer
    tmpTxTail = TWI_TxTail; // Not necessary, but prevents warnings
 8a0:	80 91 9f 00 	lds	r24, 0x009F	; 0x80009f <TWI_TxTail>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Slave/USI_TWI_Slave.c:250
    if (TWI_TxHead != tmpTxTail) {
 8a4:	90 91 a0 00 	lds	r25, 0x00A0	; 0x8000a0 <TWI_TxHead>
 8a8:	98 17       	cp	r25, r24
 8aa:	b1 f3       	breq	.-20     	; 0x898 <__vector_14+0x9e>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Slave/USI_TWI_Slave.c:251
      TWI_TxTail = (TWI_TxTail + 1) & TWI_TX_BUFFER_MASK;
 8ac:	80 91 9f 00 	lds	r24, 0x009F	; 0x80009f <TWI_TxTail>
 8b0:	8f 5f       	subi	r24, 0xFF	; 255
 8b2:	8f 70       	andi	r24, 0x0F	; 15
 8b4:	80 93 9f 00 	sts	0x009F, r24	; 0x80009f <TWI_TxTail>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Slave/USI_TWI_Slave.c:252
      USIDR      = TWI_TxBuf[TWI_TxTail];
 8b8:	e0 91 9f 00 	lds	r30, 0x009F	; 0x80009f <TWI_TxTail>
 8bc:	f0 e0       	ldi	r31, 0x00	; 0
 8be:	e0 59       	subi	r30, 0x90	; 144
 8c0:	ff 4f       	sbci	r31, 0xFF	; 255
 8c2:	80 81       	ld	r24, Z
 8c4:	8f b9       	out	0x0f, r24	; 15
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Slave/USI_TWI_Slave.c:258
    } else // If the buffer is empty then:
    {
      SET_USI_TO_TWI_START_CONDITION_MODE();
      return;
    }
    USI_TWI_Overflow_State = USI_SLAVE_REQUEST_REPLY_FROM_SEND_DATA;
 8c6:	82 e0       	ldi	r24, 0x02	; 2
 8c8:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <USI_TWI_Overflow_State>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Slave/USI_TWI_Slave.c:259
    SET_USI_TO_SEND_DATA();
 8cc:	b8 9a       	sbi	0x17, 0	; 23
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Slave/USI_TWI_Slave.c:272

  // ----- Master read data mode ------
  // Set USI to sample data from master. Next USI_SLAVE_GET_DATA_AND_SEND_ACK.
  case USI_SLAVE_REQUEST_DATA:
    USI_TWI_Overflow_State = USI_SLAVE_GET_DATA_AND_SEND_ACK;
    SET_USI_TO_READ_DATA();
 8ce:	80 e7       	ldi	r24, 0x70	; 112
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Slave/USI_TWI_Slave.c:302
      TWI_RxHead            = tmpRxHead;
      TWI_RxBuf[TWI_RxHead] = tmpUSIDR;
      SET_USI_TO_SEND_ACK();
    } else // If the buffer is full then:
    {
      SET_USI_TO_SEND_NACK();
 8d0:	8e b9       	out	0x0e, r24	; 14
 8d2:	a8 cf       	rjmp	.-176    	; 0x824 <__vector_14+0x2a>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Slave/USI_TWI_Slave.c:264
    SET_USI_TO_SEND_DATA();
    break;

  // Set USI to sample reply from master. Next USI_SLAVE_CHECK_REPLY_FROM_SEND_DATA
  case USI_SLAVE_REQUEST_REPLY_FROM_SEND_DATA:
    USI_TWI_Overflow_State = USI_SLAVE_CHECK_REPLY_FROM_SEND_DATA;
 8d4:	83 e0       	ldi	r24, 0x03	; 3
 8d6:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <USI_TWI_Overflow_State>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Slave/USI_TWI_Slave.c:265
    SET_USI_TO_READ_ACK();
 8da:	b8 98       	cbi	0x17, 0	; 23
 8dc:	1f b8       	out	0x0f, r1	; 15
 8de:	d5 cf       	rjmp	.-86     	; 0x88a <__vector_14+0x90>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Slave/USI_TWI_Slave.c:271
    break;

  // ----- Master read data mode ------
  // Set USI to sample data from master. Next USI_SLAVE_GET_DATA_AND_SEND_ACK.
  case USI_SLAVE_REQUEST_DATA:
    USI_TWI_Overflow_State = USI_SLAVE_GET_DATA_AND_SEND_ACK;
 8e0:	85 e0       	ldi	r24, 0x05	; 5
 8e2:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <USI_TWI_Overflow_State>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Slave/USI_TWI_Slave.c:272
    SET_USI_TO_READ_DATA();
 8e6:	b8 98       	cbi	0x17, 0	; 23
 8e8:	f2 cf       	rjmp	.-28     	; 0x8ce <__vector_14+0xd4>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Slave/USI_TWI_Slave.c:302
      TWI_RxHead            = tmpRxHead;
      TWI_RxBuf[TWI_RxHead] = tmpUSIDR;
      SET_USI_TO_SEND_ACK();
    } else // If the buffer is full then:
    {
      SET_USI_TO_SEND_NACK();
 8ea:	b8 98       	cbi	0x17, 0	; 23
 8ec:	ce cf       	rjmp	.-100    	; 0x88a <__vector_14+0x90>

000008ee <__vector_13>:
__vector_13():
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Slave/USI_TWI_Slave.c:165
ISR(USI_START_VECTOR)
#elif __ICCAVR__
#pragma vector = USI_START_VECTOR
__interrupt void USI_Start_Condition_ISR(void)
#endif
{
 8ee:	1f 92       	push	r1
 8f0:	0f 92       	push	r0
 8f2:	0f b6       	in	r0, 0x3f	; 63
 8f4:	0f 92       	push	r0
 8f6:	11 24       	eor	r1, r1
 8f8:	8f 93       	push	r24
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Slave/USI_TWI_Slave.c:178
      // reset rx buffer
      TWI_RxTail = tmpRxHead;
    }
  }

  USI_TWI_Overflow_State = USI_SLAVE_CHECK_ADDRESS;
 8fa:	10 92 81 00 	sts	0x0081, r1	; 0x800081 <USI_TWI_Overflow_State>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Slave/USI_TWI_Slave.c:179
  DDR_USI &= ~(1 << PORT_USI_SDA); // Set SDA as input
 8fe:	b8 98       	cbi	0x17, 0	; 23
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Slave/USI_TWI_Slave.c:180
  while ((tmpPin = (PIN_USI_CL & (1 << PORT_USI_SCL))) && ((PIN_USI & (1 << PIN_USI_SDA)) == 0))
 900:	b2 9b       	sbis	0x16, 2	; 22
 902:	04 c0       	rjmp	.+8      	; 0x90c <__vector_13+0x1e>
 904:	b0 9b       	sbis	0x16, 0	; 22
 906:	fc cf       	rjmp	.-8      	; 0x900 <__vector_13+0x12>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Slave/USI_TWI_Slave.c:185
    ; // Wait for SCL to go low to ensure the "Start Condition" has completed.
        // If a Stop condition arises then leave the interrupt to prevent waiting forever.
  if (tmpPin) {
    // Stop Condition (waiting for next Start Condition)
    USICR = (1 << USISIE) | (0 << USIOIE) | // Enable Start Condition Interrupt. Disable Overflow Interrupt.
 908:	88 ea       	ldi	r24, 0xA8	; 168
 90a:	01 c0       	rjmp	.+2      	; 0x90e <__vector_13+0x20>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Slave/USI_TWI_Slave.c:192
                                            // to first Start Condition (potential failure)
            (1 << USICS1) | (0 << USICS0) | (0 << USICLK) | // Shift Register Clock Source = External, positive edge
            (0 << USITC);
  } else {
    // really Start Condition (Enable Overflow Interrupt)
    USICR = (1 << USISIE) | (1 << USIOIE)
 90c:	88 ef       	ldi	r24, 0xF8	; 248
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Slave/USI_TWI_Slave.c:185
  while ((tmpPin = (PIN_USI_CL & (1 << PORT_USI_SCL))) && ((PIN_USI & (1 << PIN_USI_SDA)) == 0))
    ; // Wait for SCL to go low to ensure the "Start Condition" has completed.
        // If a Stop condition arises then leave the interrupt to prevent waiting forever.
  if (tmpPin) {
    // Stop Condition (waiting for next Start Condition)
    USICR = (1 << USISIE) | (0 << USIOIE) | // Enable Start Condition Interrupt. Disable Overflow Interrupt.
 90e:	8d b9       	out	0x0d, r24	; 13
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Slave/USI_TWI_Slave.c:198
            | // Enable Overflow and Start Condition Interrupt. (Keep StartCondInt to detect RESTART)
            (1 << USIWM1) | (1 << USIWM0) |                 // Set USI in Two-wire mode.
            (1 << USICS1) | (0 << USICS0) | (0 << USICLK) | // Shift Register Clock Source = External, positive edge
            (0 << USITC);
  }
  USISR = (1 << USI_START_COND_INT) | (1 << USIOIF) | (1 << USIPF) | (1 << USIDC) | // Clear flags
 910:	80 ef       	ldi	r24, 0xF0	; 240
 912:	8e b9       	out	0x0e, r24	; 14
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Slave/USI_TWI_Slave.c:200
          (0x0 << USICNT0); // Set USI to sample 8 bits i.e. count 16 external pin toggles.
}
 914:	8f 91       	pop	r24
 916:	0f 90       	pop	r0
 918:	0f be       	out	0x3f, r0	; 63
 91a:	0f 90       	pop	r0
 91c:	1f 90       	pop	r1
 91e:	18 95       	reti

00000920 <__vector_12>:
__vector_12():
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:214
ISR(PCINT0_vect) {
  int_triggered = true; 
}

// Watchdog Timer ISR
ISR(WDT_vect) {
 920:	1f 92       	push	r1
 922:	0f 92       	push	r0
 924:	0f b6       	in	r0, 0x3f	; 63
 926:	0f 92       	push	r0
 928:	11 24       	eor	r1, r1
 92a:	8f 93       	push	r24
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:215
  wdt_triggered = true;
 92c:	81 e0       	ldi	r24, 0x01	; 1
 92e:	80 93 87 00 	sts	0x0087, r24	; 0x800087 <wdt_triggered>
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:216
}
 932:	8f 91       	pop	r24
 934:	0f 90       	pop	r0
 936:	0f be       	out	0x3f, r0	; 63
 938:	0f 90       	pop	r0
 93a:	1f 90       	pop	r1
 93c:	18 95       	reti

0000093e <__vector_2>:
__vector_2():
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:209
    }
  }
}

// Interrupt Service Routine for Pin Change Interrupt on Port D
ISR(PCINT0_vect) {
 93e:	1f 92       	push	r1
 940:	0f 92       	push	r0
 942:	0f b6       	in	r0, 0x3f	; 63
 944:	0f 92       	push	r0
 946:	11 24       	eor	r1, r1
 948:	8f 93       	push	r24
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:210
  int_triggered = true; 
 94a:	81 e0       	ldi	r24, 0x01	; 1
 94c:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <int_triggered>
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:211
}
 950:	8f 91       	pop	r24
 952:	0f 90       	pop	r0
 954:	0f be       	out	0x3f, r0	; 63
 956:	0f 90       	pop	r0
 958:	1f 90       	pop	r1
 95a:	18 95       	reti

0000095c <main>:
main():
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring.c:1138
*/

  // Use the Millis Timer for fast PWM (unless it doesn't have an output).
  #if (TIMER_TO_USE_FOR_MILLIS == 0)
    #if defined(WGM01) // if Timer0 has PWM
      TCCR0A = (1<<WGM01) | (1<<WGM00);
 95c:	83 e0       	ldi	r24, 0x03	; 3
 95e:	8a bd       	out	0x2a, r24	; 42
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring.c:1141
    #endif
    #if defined(TCCR0B) //The x61 has a wacky Timer0!
      TCCR0B = (MillisTimer_Prescale_Index << CS00);
 960:	82 e0       	ldi	r24, 0x02	; 2
 962:	83 bf       	out	0x33, r24	; 51
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring.c:1162
    TCCR1A = 1<<WGM10;
    TCCR1B = (1<<WGM12) | (MillisTimer_Prescale_Index << CS10);
  #endif

  // this needs to be called before setup() or some functions won't work there
  sei();
 964:	78 94       	sei
initToneTimerInternal():
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring.c:958
    #elif defined(__AVR_ATtiny43__)
      TCCR1A = 3; //WGM 10=1, WGM11=1
      TCCR1B = 3; //prescaler of 64
    #elif (TIMER_TO_USE_FOR_TONE == 1) && defined(TCCR1) // ATtiny x5
      // Use the Tone Timer for fast PWM as phase correct not supported by this timer
      GTCCR = (1<<PWM1B);
 966:	80 e4       	ldi	r24, 0x40	; 64
 968:	8c bd       	out	0x2c, r24	; 44
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring.c:959
      OCR1C = 0xFF; //Use 255 as the top to match with the others as this module doesn't have a 8bit PWM mode.
 96a:	1f ef       	ldi	r17, 0xFF	; 255
 96c:	1d bd       	out	0x2d, r17	; 45
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring.c:960
      TCCR1 = (1<<CTC1) | (1<<PWM1A) | (ToneTimer_Prescale_Index << CS10);
 96e:	84 ec       	ldi	r24, 0xC4	; 196
 970:	80 bf       	out	0x30, r24	; 48
main():
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring.c:1214
  #if defined( INITIALIZE_ANALOG_TO_DIGITAL_CONVERTER ) && INITIALIZE_ANALOG_TO_DIGITAL_CONVERTER
    #if defined(ADCSRA)
      // set a2d prescale factor
      // ADCSRA = (ADCSRA & ~((1<<ADPS2)|(1<<ADPS1)|(1<<ADPS0))) | (ADC_ARDUINO_PRESCALER << ADPS0) | (1<<ADEN);
      // dude, this is being called on startup. We know that ADCSRA is 0! Why add a RMW cycle?!
      ADCSRA = (ADC_ARDUINO_PRESCALER << ADPS0) | (1<<ADEN);
 972:	83 e8       	ldi	r24, 0x83	; 131
 974:	86 b9       	out	0x06, r24	; 6
setup():
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:116
STC3115 gauge(110, 50, 100);    // capacity, sense resistor, internal resistance
VCNL4020 prox_sensor;

void setup() {
  /// BOARD SETUP ///
  pinMode(ALERT_PIN, OUTPUT);
 976:	61 e0       	ldi	r22, 0x01	; 1
 978:	84 e0       	ldi	r24, 0x04	; 4
 97a:	03 df       	rcall	.-506    	; 0x782 <pinMode>
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:117
  pinMode(LOWPOWER_PIN, INPUT);
 97c:	60 e0       	ldi	r22, 0x00	; 0
 97e:	81 e0       	ldi	r24, 0x01	; 1
 980:	00 df       	rcall	.-512    	; 0x782 <pinMode>
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:118
  pinMode(INT_PIN, INPUT_PULLUP);
 982:	62 e0       	ldi	r22, 0x02	; 2
 984:	83 e0       	ldi	r24, 0x03	; 3
 986:	fd de       	rcall	.-518    	; 0x782 <pinMode>
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:119
  digitalWrite(ALERT_PIN, LOW);
 988:	60 e0       	ldi	r22, 0x00	; 0
 98a:	84 e0       	ldi	r24, 0x04	; 4
 98c:	be de       	rcall	.-644    	; 0x70a <digitalWrite>
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:120
  digitalWrite(LOWPOWER_PIN, LOW);  // sets to Z while it's an input
 98e:	60 e0       	ldi	r22, 0x00	; 0
 990:	81 e0       	ldi	r24, 0x01	; 1
 992:	bb de       	rcall	.-650    	; 0x70a <digitalWrite>
begin():
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/Wire.cpp:364
}

// Public Methods //////////////////////////////////////////////////////////////

void TwoWire::begin(void) {
  BufferIndex = 0;
 994:	10 92 a3 00 	sts	0x00A3, r1	; 0x8000a3 <TwoWire::BufferIndex>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/Wire.cpp:365
  BufferLength = 0;
 998:	10 92 a4 00 	sts	0x00A4, r1	; 0x8000a4 <TwoWire::BufferLength>
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/Wire.cpp:367

  transmitting = 0;
 99c:	10 92 a2 00 	sts	0x00A2, r1	; 0x8000a2 <TwoWire::transmitting>
USI_TWI_Master_Initialise():
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Master/USI_TWI_Master.c:61
{
  #ifdef PUE_USI
  PUE_USI |=(1 << PIN_USI_SDA);
  PUE_USI_CL |=(1 << PIN_USI_SCL);
  #endif
  PORT_USI |= (1 << PIN_USI_SDA); // Enable pullup on SDA, to set high as released state.
 9a0:	c0 9a       	sbi	0x18, 0	; 24
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Master/USI_TWI_Master.c:62
  PORT_USI_CL |= (1 << PIN_USI_SCL); // Enable pullup on SCL, to set high as released state.
 9a2:	c2 9a       	sbi	0x18, 2	; 24
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Master/USI_TWI_Master.c:64

  DDR_USI_CL |= (1 << PIN_USI_SCL); // Enable SCL as output.
 9a4:	ba 9a       	sbi	0x17, 2	; 23
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Master/USI_TWI_Master.c:65
  DDR_USI |= (1 << PIN_USI_SDA); // Enable SDA as output.
 9a6:	b8 9a       	sbi	0x17, 0	; 23
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Master/USI_TWI_Master.c:67

  USIDR = 0xFF;                                           // Preload dataregister with "released level" data.
 9a8:	1f b9       	out	0x0f, r17	; 15
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Master/USI_TWI_Master.c:68
  USICR = (0 << USISIE) | (0 << USIOIE) |                 // Disable Interrupts.
 9aa:	8a e2       	ldi	r24, 0x2A	; 42
 9ac:	8d b9       	out	0x0d, r24	; 13
/Users/aesters/Library/Arduino15/packages/ATTinyCore/hardware/avr/1.5.2/libraries/Wire/src/USI_TWI_Master/USI_TWI_Master.c:72
          (1 << USIWM1) | (0 << USIWM0) |                 // Set USI in Two-wire mode.
          (1 << USICS1) | (0 << USICS0) | (1 << USICLK) | // Software stobe as counter clock source
          (0 << USITC);
  USISR = (1 << USISIF) | (1 << USIOIF) | (1 << USIPF) | (1 << USIDC) | // Clear flags,
 9ae:	80 ef       	ldi	r24, 0xF0	; 240
 9b0:	8e b9       	out	0x0e, r24	; 14
setup():
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:122
  Wire.begin();  // initialize I2C
  delay(50);
 9b2:	62 e3       	ldi	r22, 0x32	; 50
 9b4:	70 e0       	ldi	r23, 0x00	; 0
 9b6:	80 e0       	ldi	r24, 0x00	; 0
 9b8:	90 e0       	ldi	r25, 0x00	; 0
 9ba:	c8 db       	rcall	.-2160   	; 0x14c <delay>
setupSensors():
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:224

// Configure sensors
void setupSensors() 
{
  // Disable magnetometer
  i2cWrite(0b11, ADDR_MAG, CFG_REG_A_M, 1);
 9bc:	40 e6       	ldi	r20, 0x60	; 96
 9be:	6e e1       	ldi	r22, 0x1E	; 30
 9c0:	83 e0       	ldi	r24, 0x03	; 3
 9c2:	77 dc       	rcall	.-1810   	; 0x2b2 <i2cWrite(unsigned char, unsigned char, unsigned char, unsigned char, bool) [clone .constprop.37]>
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:227

  // Set up accelerometer
  i2cWrite(0b00100010, ADDR_ACCEL, CTRL_REG1_A, 1);   // normal mode, 10 Hz, enable Y-axis
 9c4:	40 e2       	ldi	r20, 0x20	; 32
 9c6:	69 e1       	ldi	r22, 0x19	; 25
 9c8:	82 e2       	ldi	r24, 0x22	; 34
 9ca:	73 dc       	rcall	.-1818   	; 0x2b2 <i2cWrite(unsigned char, unsigned char, unsigned char, unsigned char, bool) [clone .constprop.37]>
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:228
  i2cWrite(0, ADDR_ACCEL, CTRL_REG4_A, 1);            // full scale = +/-2 g
 9cc:	43 e2       	ldi	r20, 0x23	; 35
 9ce:	69 e1       	ldi	r22, 0x19	; 25
 9d0:	80 e0       	ldi	r24, 0x00	; 0
 9d2:	6f dc       	rcall	.-1826   	; 0x2b2 <i2cWrite(unsigned char, unsigned char, unsigned char, unsigned char, bool) [clone .constprop.37]>
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:229
  i2cWrite(0b00100010, ADDR_ACCEL, CTRL_REG6_A, 1);   // enable interrupt, active-low on INT2
 9d4:	45 e2       	ldi	r20, 0x25	; 37
 9d6:	69 e1       	ldi	r22, 0x19	; 25
 9d8:	82 e2       	ldi	r24, 0x22	; 34
 9da:	6b dc       	rcall	.-1834   	; 0x2b2 <i2cWrite(unsigned char, unsigned char, unsigned char, unsigned char, bool) [clone .constprop.37]>
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:230
  i2cWrite(1 << 3, ADDR_ACCEL, INT2_CFG_A, 1);        // INT2 activates when abs(y) > threshold
 9dc:	44 e3       	ldi	r20, 0x34	; 52
 9de:	69 e1       	ldi	r22, 0x19	; 25
 9e0:	88 e0       	ldi	r24, 0x08	; 8
 9e2:	67 dc       	rcall	.-1842   	; 0x2b2 <i2cWrite(unsigned char, unsigned char, unsigned char, unsigned char, bool) [clone .constprop.37]>
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:231
  i2cWrite(static_cast<uint8_t>(accel_threshold/9.8*1000/(2000./128)), ADDR_ACCEL, INT2_THS_A, 1);  // set threshold for interrupt
 9e4:	46 e3       	ldi	r20, 0x36	; 54
 9e6:	69 e1       	ldi	r22, 0x19	; 25
 9e8:	84 e3       	ldi	r24, 0x34	; 52
 9ea:	63 dc       	rcall	.-1850   	; 0x2b2 <i2cWrite(unsigned char, unsigned char, unsigned char, unsigned char, bool) [clone .constprop.37]>
VCNL4020_Init():
/Users/aesters/Documents/Arduino/libraries/vcnl4020-arduino-driver/src/VCNL4020.cpp:19

// Initialize sensor in idle state
VCNL4020_Status VCNL4020_Init(VCNL4020 *pDevice) 
{
    // Initial delay to allow sensor to power up
    delay(10);
 9ec:	6a e0       	ldi	r22, 0x0A	; 10
 9ee:	70 e0       	ldi	r23, 0x00	; 0
 9f0:	80 e0       	ldi	r24, 0x00	; 0
 9f2:	90 e0       	ldi	r25, 0x00	; 0
 9f4:	ab db       	rcall	.-2218   	; 0x14c <delay>
/Users/aesters/Documents/Arduino/libraries/vcnl4020-arduino-driver/src/VCNL4020.cpp:22

    // Set the sensor's initial configuration
    pDevice->address = 0x13;    // Default I2C address
 9f6:	83 e1       	ldi	r24, 0x13	; 19
 9f8:	80 93 98 00 	sts	0x0098, r24	; 0x800098 <prox_sensor>
/Users/aesters/Documents/Arduino/libraries/vcnl4020-arduino-driver/src/VCNL4020.cpp:23
    pDevice->current = 0; 
 9fc:	10 92 99 00 	sts	0x0099, r1	; 0x800099 <prox_sensor+0x1>
/Users/aesters/Documents/Arduino/libraries/vcnl4020-arduino-driver/src/VCNL4020.cpp:24
    pDevice->mode = MANUAL;
 a00:	10 92 9a 00 	sts	0x009A, r1	; 0x80009a <prox_sensor+0x2>
/Users/aesters/Documents/Arduino/libraries/vcnl4020-arduino-driver/src/VCNL4020.cpp:25
    pDevice->prox_rate = 0;
 a04:	10 92 9b 00 	sts	0x009B, r1	; 0x80009b <prox_sensor+0x3>
/Users/aesters/Documents/Arduino/libraries/vcnl4020-arduino-driver/src/VCNL4020.cpp:28

    // Check if sensor is connected via I2C
    pDevice->connected = VCNL4020_IsConnected(pDevice);
 a08:	2b de       	rcall	.-938    	; 0x660 <VCNL4020_IsConnected.constprop.28>
 a0a:	80 93 9c 00 	sts	0x009C, r24	; 0x80009c <prox_sensor+0x4>
VCNL4020_SetCurrent():
/Users/aesters/Documents/Arduino/libraries/vcnl4020-arduino-driver/src/VCNL4020.cpp:51
VCNL4020_Status VCNL4020_SetCurrent(VCNL4020 *pDevice, uint8_t led_current) 
{
    uint8_t reg_value = 0;

    // Check for connection
    pDevice->connected = VCNL4020_IsConnected(pDevice);
 a0e:	28 de       	rcall	.-944    	; 0x660 <VCNL4020_IsConnected.constprop.28>
 a10:	80 93 9c 00 	sts	0x009C, r24	; 0x80009c <prox_sensor+0x4>
/Users/aesters/Documents/Arduino/libraries/vcnl4020-arduino-driver/src/VCNL4020.cpp:52
    if (!pDevice->connected) {
 a14:	88 23       	and	r24, r24
 a16:	49 f0       	breq	.+18     	; 0xa2a <main+0xce>
/Users/aesters/Documents/Arduino/libraries/vcnl4020-arduino-driver/src/VCNL4020.cpp:63
        return STATUS_INVALID_PARAM;     // Invalid current value
    }
    
    // Write to register via I2C
    reg_value = led_current / 10;
    I2C_WriteRegister(pDevice->address, REG_CURRENT, 1, reg_value);
 a18:	4f e0       	ldi	r20, 0x0F	; 15
 a1a:	50 e0       	ldi	r21, 0x00	; 0
 a1c:	63 e8       	ldi	r22, 0x83	; 131
 a1e:	80 91 98 00 	lds	r24, 0x0098	; 0x800098 <prox_sensor>
 a22:	54 dc       	rcall	.-1880   	; 0x2cc <I2C_WriteRegister.constprop.35>
/Users/aesters/Documents/Arduino/libraries/vcnl4020-arduino-driver/src/VCNL4020.cpp:64
    pDevice->current = led_current;
 a24:	86 e9       	ldi	r24, 0x96	; 150
 a26:	80 93 99 00 	sts	0x0099, r24	; 0x800099 <prox_sensor+0x1>
VCNL4020_SetMode():
/Users/aesters/Documents/Arduino/libraries/vcnl4020-arduino-driver/src/VCNL4020.cpp:74
VCNL4020_Status VCNL4020_SetMode(VCNL4020 *pDevice, VCNL4020_Mode mode) 
{
    uint8_t reg_value = 0;

    // Check for connection
    pDevice->connected = VCNL4020_IsConnected(pDevice);
 a2a:	1a de       	rcall	.-972    	; 0x660 <VCNL4020_IsConnected.constprop.28>
 a2c:	80 93 9c 00 	sts	0x009C, r24	; 0x80009c <prox_sensor+0x4>
/Users/aesters/Documents/Arduino/libraries/vcnl4020-arduino-driver/src/VCNL4020.cpp:75
    if (!pDevice->connected) {
 a30:	88 23       	and	r24, r24
 a32:	69 f0       	breq	.+26     	; 0xa4e <main+0xf2>
/Users/aesters/Documents/Arduino/libraries/vcnl4020-arduino-driver/src/VCNL4020.cpp:85
    if (mode > 0x07) {
        return STATUS_INVALID_PARAM; // Invalid mode
    }

    // Update bits 0-2 based on mode
    I2C_WriteRegister(pDevice->address, REG_COMMAND, 1, mode);
 a34:	50 e0       	ldi	r21, 0x00	; 0
 a36:	40 e0       	ldi	r20, 0x00	; 0
 a38:	60 e8       	ldi	r22, 0x80	; 128
 a3a:	80 91 98 00 	lds	r24, 0x0098	; 0x800098 <prox_sensor>
 a3e:	46 dc       	rcall	.-1908   	; 0x2cc <I2C_WriteRegister.constprop.35>
/Users/aesters/Documents/Arduino/libraries/vcnl4020-arduino-driver/src/VCNL4020.cpp:86
    delay(10);
 a40:	6a e0       	ldi	r22, 0x0A	; 10
 a42:	70 e0       	ldi	r23, 0x00	; 0
 a44:	80 e0       	ldi	r24, 0x00	; 0
 a46:	90 e0       	ldi	r25, 0x00	; 0
 a48:	81 db       	rcall	.-2302   	; 0x14c <delay>
/Users/aesters/Documents/Arduino/libraries/vcnl4020-arduino-driver/src/VCNL4020.cpp:89

    // Update struct
    pDevice->mode = mode;
 a4a:	10 92 9a 00 	sts	0x009A, r1	; 0x80009a <prox_sensor+0x2>
setupSensors():
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:238

  // Set up proximity sensor
  VCNL4020_Init(&prox_sensor);
  VCNL4020_SetCurrent(&prox_sensor, led_current);   // set IR LED current
  VCNL4020_SetMode(&prox_sensor, MANUAL);           // get measurements on demand 
  delay(10);   
 a4e:	6a e0       	ldi	r22, 0x0A	; 10
 a50:	70 e0       	ldi	r23, 0x00	; 0
 a52:	80 e0       	ldi	r24, 0x00	; 0
 a54:	90 e0       	ldi	r25, 0x00	; 0
 a56:	7a db       	rcall	.-2316   	; 0x14c <delay>
setup():
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:126
  Wire.begin();  // initialize I2C
  delay(50);

  /// CONFIGURE ALL DEVICES ///
  setupSensors();     // accelerometer and IR sensor
  gauge.startup();    // battery fuel gauge
 a58:	8f dd       	rcall	.-1250   	; 0x578 <STC3115::startup() [clone .constprop.5]>
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:134
  if (do_calib) {
    background = proxCalibration(&prox_sensor);
    prox_threshold = pthresh_with_calib;
  } 
  else {
    background = 0;
 a5a:	10 92 85 00 	sts	0x0085, r1	; 0x800085 <background+0x1>
 a5e:	10 92 84 00 	sts	0x0084, r1	; 0x800084 <background>
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:135
    prox_threshold = pthresh_no_calib;
 a62:	8c ea       	ldi	r24, 0xAC	; 172
 a64:	9d e0       	ldi	r25, 0x0D	; 13
 a66:	90 93 83 00 	sts	0x0083, r25	; 0x800083 <prox_threshold+0x1>
 a6a:	80 93 82 00 	sts	0x0082, r24	; 0x800082 <prox_threshold>
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:140
  }
  //background = proxCalibration(&prox_sensor);

  /// SET UP SLEEP/INTERRUPT LOGIC ///
  cli(); // Disable interrupts temporarily
 a6e:	f8 94       	cli
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:143

  // Enable Pin Change Interrupt on PB3 (Pin 2 on ATtiny85)
  GIMSK |= (1 << PCIE);    // Enable Pin Change Interrupts
 a70:	8b b7       	in	r24, 0x3b	; 59
 a72:	80 62       	ori	r24, 0x20	; 32
 a74:	8b bf       	out	0x3b, r24	; 59
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:144
  PCMSK |= (1 << PCINT3); // Enable Pin Change Interrupt on PB3
 a76:	ab 9a       	sbi	0x15, 3	; 21
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:145
  sleep_bod_disable(); // Disable brown-out detector
 a78:	85 b7       	in	r24, 0x35	; 53
 a7a:	84 68       	ori	r24, 0x84	; 132
 a7c:	85 bf       	out	0x35, r24	; 53
 a7e:	8b 7f       	andi	r24, 0xFB	; 251
 a80:	85 bf       	out	0x35, r24	; 53
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:148

  // Configure Watchdog Timer (WDT) for periodic wake-ups
  wdt_reset(); // Reset the WDT
 a82:	a8 95       	wdr
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:149
  WDTCR |= (1 << WDCE) | (1 << WDE);  // Enable WDT change
 a84:	81 b5       	in	r24, 0x21	; 33
 a86:	88 61       	ori	r24, 0x18	; 24
 a88:	81 bd       	out	0x21, r24	; 33
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:150
  WDTCR = (1 << WDP3) | (1 << WDP0); // Set timeout to max (8 seconds)
 a8a:	81 e2       	ldi	r24, 0x21	; 33
 a8c:	81 bd       	out	0x21, r24	; 33
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:151
  WDTCR |= (1 << WDIE);              // Enable WDT interrupt mode (no reset)
 a8e:	81 b5       	in	r24, 0x21	; 33
 a90:	80 64       	ori	r24, 0x40	; 64
 a92:	81 bd       	out	0x21, r24	; 33
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:153

  sei(); // Re-enable interrupts
 a94:	78 94       	sei
loop():
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:159
}

void loop() 
{
  // increment when woken by watchdog timer
  if (wdt_triggered) {
 a96:	80 91 87 00 	lds	r24, 0x0087	; 0x800087 <wdt_triggered>
 a9a:	88 23       	and	r24, r24
 a9c:	41 f0       	breq	.+16     	; 0xaae <main+0x152>
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:160
    wdt_triggered = false;
 a9e:	10 92 87 00 	sts	0x0087, r1	; 0x800087 <wdt_triggered>
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:164
    wdt_counter++;

    // time to check battery level
    if (wdt_counter >= counter_max) {
 aa2:	80 91 86 00 	lds	r24, 0x0086	; 0x800086 <wdt_counter>
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:165
      wdt_counter = 0;  // reset counter
 aa6:	10 92 86 00 	sts	0x0086, r1	; 0x800086 <wdt_counter>
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:164
  if (wdt_triggered) {
    wdt_triggered = false;
    wdt_counter++;

    // time to check battery level
    if (wdt_counter >= counter_max) {
 aaa:	8f 3f       	cpi	r24, 0xFF	; 255
 aac:	49 f4       	brne	.+18     	; 0xac0 <main+0x164>
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:178
      }
    }
  }

  // go back to sleep if interrupt is HIGH
  if (digitalRead(INT_PIN) == HIGH) { 
 aae:	27 de       	rcall	.-946    	; 0x6fe <digitalRead.constprop.2>
 ab0:	01 97       	sbiw	r24, 0x01	; 1
 ab2:	09 f0       	breq	.+2      	; 0xab6 <main+0x15a>
 ab4:	5c c0       	rjmp	.+184    	; 0xb6e <main+0x212>
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:180
    //i2cWrite(1, ADDR_PROX, PROX_REG_00, 1);   // stop prox measurements
    digitalWrite(ALERT_PIN, LOW);
 ab6:	60 e0       	ldi	r22, 0x00	; 0
 ab8:	84 e0       	ldi	r24, 0x04	; 4
 aba:	27 de       	rcall	.-946    	; 0x70a <digitalWrite>
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:190
  else if (digitalRead(INT_PIN) == LOW) {
    accel = readAccelY();

    // positive acceleration = not the signal we want
    if (accel > 0) {  
      goToSleep();    // arm is down, go back to sleep
 abc:	30 dc       	rcall	.-1952   	; 0x31e <goToSleep()>
 abe:	eb cf       	rjmp	.-42     	; 0xa96 <main+0x13a>
check():
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:169
}

// Ensure that component is running, or restart if needed -> great for Arduino loop()
void STC3115::check() 
{
  uint8_t tempCtrl = read<uint8_t>(REG_CTRL, 1);
 ac0:	81 e0       	ldi	r24, 0x01	; 1
 ac2:	5b dc       	rcall	.-1866   	; 0x37a <unsigned char STC3115::read<unsigned char>(unsigned char, unsigned char) [clone .isra.0] [clone .constprop.17]>
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:170
  uint8_t issues = (tempCtrl >> 3) & 0b11;        // examine two bits
 ac4:	90 e0       	ldi	r25, 0x00	; 0
 ac6:	23 e0       	ldi	r18, 0x03	; 3
 ac8:	95 95       	asr	r25
 aca:	87 95       	ror	r24
 acc:	2a 95       	dec	r18
 ace:	e1 f7       	brne	.-8      	; 0xac8 <main+0x16c>
 ad0:	83 70       	andi	r24, 0x03	; 3
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:171
  if (issues) {
 ad2:	09 f4       	brne	.+2      	; 0xad6 <main+0x17a>
 ad4:	4a c0       	rjmp	.+148    	; 0xb6a <main+0x20e>
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:173
    DEBUG_PRINT("Power-on issue detected. Restarting...");
    startup();    // run startup routine to take care of issues
 ad6:	50 dd       	rcall	.-1376   	; 0x578 <STC3115::startup() [clone .constprop.5]>
readSOC():
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:249
}

// Read battery SOC (state of charge)
float STC3115::readSOC()
{
  uint16_t rawValue = read<uint16_t>(REG_SOC, 2);
 ad8:	82 e0       	ldi	r24, 0x02	; 2
 ada:	73 dc       	rcall	.-1818   	; 0x3c2 <unsigned int STC3115::read<unsigned int>(unsigned char, unsigned char) [clone .isra.2] [clone .constprop.12]>
 adc:	8c 01       	movw	r16, r24
loop():
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:170
      wdt_counter = 0;  // reset counter
      
      // compare state-of-charge to threshold
      gauge.check();    // make sure gauge is running
      float soc = gauge.readSOC();
      delay(100);
 ade:	64 e6       	ldi	r22, 0x64	; 100
 ae0:	70 e0       	ldi	r23, 0x00	; 0
 ae2:	80 e0       	ldi	r24, 0x00	; 0
 ae4:	90 e0       	ldi	r25, 0x00	; 0
 ae6:	32 db       	rcall	.-2460   	; 0x14c <delay>
readSOC():
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:250
  float soc = rawValue * 1.0/512.0;     // convert to % charge
 ae8:	b8 01       	movw	r22, r16
 aea:	90 e0       	ldi	r25, 0x00	; 0
 aec:	80 e0       	ldi	r24, 0x00	; 0
 aee:	30 d1       	rcall	.+608    	; 0xd50 <__floatunsisf>
 af0:	20 e0       	ldi	r18, 0x00	; 0
 af2:	30 e0       	ldi	r19, 0x00	; 0
 af4:	40 e0       	ldi	r20, 0x00	; 0
 af6:	5b e3       	ldi	r21, 0x3B	; 59
 af8:	e1 d1       	rcall	.+962    	; 0xebc <__mulsf3>
loop():
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:171
      if (soc <= lowBatteryThreshold) {
 afa:	20 e0       	ldi	r18, 0x00	; 0
 afc:	30 e0       	ldi	r19, 0x00	; 0
 afe:	40 ea       	ldi	r20, 0xA0	; 160
 b00:	51 e4       	ldi	r21, 0x41	; 65
 b02:	8e d0       	rcall	.+284    	; 0xc20 <__cmpsf2>
 b04:	18 16       	cp	r1, r24
 b06:	9c f2       	brlt	.-90     	; 0xaae <main+0x152>
 b08:	03 e0       	ldi	r16, 0x03	; 3
 b0a:	10 e0       	ldi	r17, 0x00	; 0
lowBatteryAlert():
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:296

// Send low battery alert periodically
void lowBatteryAlert() 
{
  for (int i=0; i<3; i++) {  // toggle buzzer and LED
    digitalWrite(ALERT_PIN, HIGH);
 b0c:	61 e0       	ldi	r22, 0x01	; 1
 b0e:	84 e0       	ldi	r24, 0x04	; 4
 b10:	fc dd       	rcall	.-1032   	; 0x70a <digitalWrite>
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:297
    pinMode(LOWPOWER_PIN, OUTPUT);  // pin goes to 0 -> LED ON
 b12:	61 e0       	ldi	r22, 0x01	; 1
 b14:	81 e0       	ldi	r24, 0x01	; 1
 b16:	35 de       	rcall	.-918    	; 0x782 <pinMode>
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:298
    delay(500);
 b18:	64 ef       	ldi	r22, 0xF4	; 244
 b1a:	71 e0       	ldi	r23, 0x01	; 1
 b1c:	80 e0       	ldi	r24, 0x00	; 0
 b1e:	90 e0       	ldi	r25, 0x00	; 0
 b20:	15 db       	rcall	.-2518   	; 0x14c <delay>
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:299
    digitalWrite(ALERT_PIN, LOW);
 b22:	60 e0       	ldi	r22, 0x00	; 0
 b24:	84 e0       	ldi	r24, 0x04	; 4
 b26:	f1 dd       	rcall	.-1054   	; 0x70a <digitalWrite>
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:300
    pinMode(LOWPOWER_PIN, INPUT);   // pin goes to Z -> LED OFF
 b28:	60 e0       	ldi	r22, 0x00	; 0
 b2a:	81 e0       	ldi	r24, 0x01	; 1
 b2c:	2a de       	rcall	.-940    	; 0x782 <pinMode>
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:301
    delay(500);
 b2e:	64 ef       	ldi	r22, 0xF4	; 244
 b30:	71 e0       	ldi	r23, 0x01	; 1
 b32:	80 e0       	ldi	r24, 0x00	; 0
 b34:	90 e0       	ldi	r25, 0x00	; 0
 b36:	0a db       	rcall	.-2540   	; 0x14c <delay>
 b38:	01 50       	subi	r16, 0x01	; 1
 b3a:	11 09       	sbc	r17, r1
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:295
}

// Send low battery alert periodically
void lowBatteryAlert() 
{
  for (int i=0; i<3; i++) {  // toggle buzzer and LED
 b3c:	39 f7       	brne	.-50     	; 0xb0c <main+0x1b0>
 b3e:	04 e0       	ldi	r16, 0x04	; 4
 b40:	10 e0       	ldi	r17, 0x00	; 0
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:304
    digitalWrite(ALERT_PIN, LOW);
    pinMode(LOWPOWER_PIN, INPUT);   // pin goes to Z -> LED OFF
    delay(500);
  }
  for (int i=0; i<4; i++) {  // toggle LED a few more times
    pinMode(LOWPOWER_PIN, OUTPUT);  // pin goes to 0
 b42:	61 e0       	ldi	r22, 0x01	; 1
 b44:	81 e0       	ldi	r24, 0x01	; 1
 b46:	1d de       	rcall	.-966    	; 0x782 <pinMode>
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:305
    delay(500);
 b48:	64 ef       	ldi	r22, 0xF4	; 244
 b4a:	71 e0       	ldi	r23, 0x01	; 1
 b4c:	80 e0       	ldi	r24, 0x00	; 0
 b4e:	90 e0       	ldi	r25, 0x00	; 0
 b50:	fd da       	rcall	.-2566   	; 0x14c <delay>
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:306
    pinMode(LOWPOWER_PIN, INPUT);   // pin goes to Z
 b52:	60 e0       	ldi	r22, 0x00	; 0
 b54:	81 e0       	ldi	r24, 0x01	; 1
 b56:	15 de       	rcall	.-982    	; 0x782 <pinMode>
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:307
    delay(500);
 b58:	64 ef       	ldi	r22, 0xF4	; 244
 b5a:	71 e0       	ldi	r23, 0x01	; 1
 b5c:	80 e0       	ldi	r24, 0x00	; 0
 b5e:	90 e0       	ldi	r25, 0x00	; 0
 b60:	f5 da       	rcall	.-2582   	; 0x14c <delay>
 b62:	01 50       	subi	r16, 0x01	; 1
 b64:	11 09       	sbc	r17, r1
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:303
    delay(500);
    digitalWrite(ALERT_PIN, LOW);
    pinMode(LOWPOWER_PIN, INPUT);   // pin goes to Z -> LED OFF
    delay(500);
  }
  for (int i=0; i<4; i++) {  // toggle LED a few more times
 b66:	69 f7       	brne	.-38     	; 0xb42 <main+0x1e6>
 b68:	a2 cf       	rjmp	.-188    	; 0xaae <main+0x152>
check():
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:176
  if (issues) {
    DEBUG_PRINT("Power-on issue detected. Restarting...");
    startup();    // run startup routine to take care of issues
  }
  else {
    run();        // make sure we're in run mode
 b6a:	1a dc       	rcall	.-1996   	; 0x3a0 <STC3115::run() [clone .constprop.7]>
 b6c:	b5 cf       	rjmp	.-150    	; 0xad8 <main+0x17c>
loop():
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:185
    digitalWrite(ALERT_PIN, LOW);
    goToSleep();
  }

  // check accel reading if interrupt is LOW
  else if (digitalRead(INT_PIN) == LOW) {
 b6e:	c7 dd       	rcall	.-1138   	; 0x6fe <digitalRead.constprop.2>
 b70:	89 2b       	or	r24, r25
 b72:	09 f0       	breq	.+2      	; 0xb76 <main+0x21a>
 b74:	90 cf       	rjmp	.-224    	; 0xa96 <main+0x13a>
i2cRead():
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:63
T i2cRead(uint8_t deviceAddress, uint8_t startRegister, uint8_t numBytes, bool bigEndian = false) 
{ 
  uint16_t rawValue = 0;   // max: 2 bytes worth  

  // start I2C comms with device
  Wire.beginTransmission(deviceAddress);  
 b76:	89 e1       	ldi	r24, 0x19	; 25
 b78:	b0 da       	rcall	.-2720   	; 0xda <TwoWire::beginTransmission(unsigned char) [clone .constprop.38]>
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:66

  // set target register for reading
  Wire.write(startRegister);
 b7a:	8a ea       	ldi	r24, 0xAA	; 170
 b7c:	7b da       	rcall	.-2826   	; 0x74 <TwoWire::write(unsigned char) [clone .constprop.39]>
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:67
  Wire.endTransmission();
 b7e:	79 db       	rcall	.-2318   	; 0x272 <TwoWire::endTransmission() [clone .constprop.40]>
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:70

  // read contents from consecutive registers
  Wire.requestFrom(deviceAddress, numBytes); 
 b80:	62 e0       	ldi	r22, 0x02	; 2
 b82:	89 e1       	ldi	r24, 0x19	; 25
 b84:	de db       	rcall	.-2116   	; 0x342 <TwoWire::requestFrom(unsigned char, unsigned char) [clone .constprop.29]>
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:72
  for (int i = 0; i < numBytes; i++) {    
    uint8_t currentByte = Wire.read();
 b86:	b4 da       	rcall	.-2712   	; 0xf0 <TwoWire::read() [clone .constprop.32]>
 b88:	18 2f       	mov	r17, r24
 b8a:	b2 da       	rcall	.-2716   	; 0xf0 <TwoWire::read() [clone .constprop.32]>
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:77
    if (bigEndian) {
      rawValue |= uint16_t (currentByte << 8*(numBytes - 1 - i));
    }
    else {
      rawValue |= uint16_t (currentByte << 8*i);
 b8c:	d8 2f       	mov	r29, r24
 b8e:	80 e0       	ldi	r24, 0x00	; 0
 b90:	c8 2f       	mov	r28, r24
 b92:	be 01       	movw	r22, r28
 b94:	61 2b       	or	r22, r17
readAccelY():
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:277
// Read acceleration along Y axis
float readAccelY() 
{
  // get acceleration readings (must set MSB to 1 to read consecutive registers)
  int16_t rawValue = i2cRead<int16_t>(ADDR_ACCEL, ACCEL_OUT_Y | (1 << 7), 2); 
  rawValue = rawValue >> 6;  // remove lower 6 bits
 b96:	86 e0       	ldi	r24, 0x06	; 6
 b98:	75 95       	asr	r23
 b9a:	67 95       	ror	r22
 b9c:	8a 95       	dec	r24
 b9e:	e1 f7       	brne	.-8      	; 0xb98 <main+0x23c>
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:280

  // convert to signed int, then convert to m/s^2 (normal mode = 3.9 milli-g per bit)
  return 3.9 * 9.8 / 1000 * rawValue;
 ba0:	07 2e       	mov	r0, r23
 ba2:	00 0c       	add	r0, r0
 ba4:	88 0b       	sbc	r24, r24
 ba6:	99 0b       	sbc	r25, r25
 ba8:	d5 d0       	rcall	.+426    	; 0xd54 <__floatsisf>
 baa:	23 e9       	ldi	r18, 0x93	; 147
 bac:	3c e8       	ldi	r19, 0x8C	; 140
 bae:	4c e1       	ldi	r20, 0x1C	; 28
 bb0:	5d e3       	ldi	r21, 0x3D	; 61
 bb2:	84 d1       	rcall	.+776    	; 0xebc <__mulsf3>
loop():
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:189
  // check accel reading if interrupt is LOW
  else if (digitalRead(INT_PIN) == LOW) {
    accel = readAccelY();

    // positive acceleration = not the signal we want
    if (accel > 0) {  
 bb4:	20 e0       	ldi	r18, 0x00	; 0
 bb6:	30 e0       	ldi	r19, 0x00	; 0
 bb8:	a9 01       	movw	r20, r18
 bba:	7c d1       	rcall	.+760    	; 0xeb4 <__gesf2>
 bbc:	18 16       	cp	r1, r24
 bbe:	0c f4       	brge	.+2      	; 0xbc2 <main+0x266>
 bc0:	7d cf       	rjmp	.-262    	; 0xabc <main+0x160>
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:195
      goToSleep();    // arm is down, go back to sleep
    }
    // positive acceleration = the signal we want
    else {   
      // check if prox reading > threshold
      prox = VCNL4020_ReadProximity(&prox_sensor);
 bc2:	68 dd       	rcall	.-1328   	; 0x694 <VCNL4020_ReadProximity.constprop.19>
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:196
      prox = prox - background;
 bc4:	20 91 84 00 	lds	r18, 0x0084	; 0x800084 <background>
 bc8:	30 91 85 00 	lds	r19, 0x0085	; 0x800085 <background+0x1>
 bcc:	82 1b       	sub	r24, r18
 bce:	93 0b       	sbc	r25, r19
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:197
      if (prox > prox_threshold) {  
 bd0:	20 91 82 00 	lds	r18, 0x0082	; 0x800082 <prox_threshold>
 bd4:	30 91 83 00 	lds	r19, 0x0083	; 0x800083 <prox_threshold+0x1>
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:198
        digitalWrite(ALERT_PIN, HIGH);  // activate buzzer
 bd8:	61 e0       	ldi	r22, 0x01	; 1
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:197
    // positive acceleration = the signal we want
    else {   
      // check if prox reading > threshold
      prox = VCNL4020_ReadProximity(&prox_sensor);
      prox = prox - background;
      if (prox > prox_threshold) {  
 bda:	28 17       	cp	r18, r24
 bdc:	39 07       	cpc	r19, r25
 bde:	08 f0       	brcs	.+2      	; 0xbe2 <main+0x286>
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:200
        digitalWrite(ALERT_PIN, HIGH);  // activate buzzer
      } else {
        digitalWrite(ALERT_PIN, LOW);   // deactivate buzzer
 be0:	60 e0       	ldi	r22, 0x00	; 0
 be2:	84 e0       	ldi	r24, 0x04	; 4
 be4:	92 dd       	rcall	.-1244   	; 0x70a <digitalWrite>
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:202
      }
      VCNL4020_ClearInterrupts(&prox_sensor);
 be6:	47 dd       	rcall	.-1394   	; 0x676 <VCNL4020_ClearInterrupts.constprop.21>
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:203
      delay(period);
 be8:	68 ec       	ldi	r22, 0xC8	; 200
 bea:	70 e0       	ldi	r23, 0x00	; 0
 bec:	80 e0       	ldi	r24, 0x00	; 0
 bee:	90 e0       	ldi	r25, 0x00	; 0
 bf0:	ad da       	rcall	.-2726   	; 0x14c <delay>
 bf2:	51 cf       	rjmp	.-350    	; 0xa96 <main+0x13a>

00000bf4 <_GLOBAL__sub_I_prox_threshold>:
_GLOBAL__sub_I_prox_threshold():
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:17
  #define DEBUG_PRINT(x)  // Does nothing when DEBUG is 0
#endif
// F() macro is used to store strings in flash memory instead of SRAM

// Constructor implementation
STC3115::STC3115(uint16_t capacity = 0, uint8_t rsense = 0, uint16_t resInt = 0) {
 bf4:	ee e8       	ldi	r30, 0x8E	; 142
 bf6:	f0 e0       	ldi	r31, 0x00	; 0
 bf8:	89 e0       	ldi	r24, 0x09	; 9
 bfa:	df 01       	movw	r26, r30
 bfc:	1d 92       	st	X+, r1
 bfe:	8a 95       	dec	r24
 c00:	e9 f7       	brne	.-6      	; 0xbfc <_GLOBAL__sub_I_prox_threshold+0x8>
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:18
  _address = 0b1110000;   // default I2C address
 c02:	e8 e8       	ldi	r30, 0x88	; 136
 c04:	f0 e0       	ldi	r31, 0x00	; 0
 c06:	80 e7       	ldi	r24, 0x70	; 112
 c08:	80 83       	st	Z, r24
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:19
  _capacity = capacity;
 c0a:	8e e6       	ldi	r24, 0x6E	; 110
 c0c:	90 e0       	ldi	r25, 0x00	; 0
 c0e:	92 83       	std	Z+2, r25	; 0x02
 c10:	81 83       	std	Z+1, r24	; 0x01
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:20
  _rsense = rsense;
 c12:	82 e3       	ldi	r24, 0x32	; 50
 c14:	83 83       	std	Z+3, r24	; 0x03
/Users/aesters/Documents/Arduino/libraries/STC3115/src/STC3115.cpp:21
  _resInt = resInt;         
 c16:	84 e6       	ldi	r24, 0x64	; 100
 c18:	90 e0       	ldi	r25, 0x00	; 0
 c1a:	95 83       	std	Z+5, r25	; 0x05
 c1c:	84 83       	std	Z+4, r24	; 0x04
/Users/aesters/Documents/Arduino/dtyf_beta_dev_board_3/dtyf_beta_dev_board_3.ino:309
    pinMode(LOWPOWER_PIN, OUTPUT);  // pin goes to 0
    delay(500);
    pinMode(LOWPOWER_PIN, INPUT);   // pin goes to Z
    delay(500);
  }
}
 c1e:	08 95       	ret

00000c20 <__cmpsf2>:
__cmpsf2():
 c20:	d4 d0       	rcall	.+424    	; 0xdca <__fp_cmp>
 c22:	08 f4       	brcc	.+2      	; 0xc26 <__cmpsf2+0x6>
 c24:	81 e0       	ldi	r24, 0x01	; 1
 c26:	08 95       	ret

00000c28 <__divsf3>:
__divsf3():
 c28:	0c d0       	rcall	.+24     	; 0xc42 <__divsf3x>
 c2a:	0a c1       	rjmp	.+532    	; 0xe40 <__fp_round>
 c2c:	02 d1       	rcall	.+516    	; 0xe32 <__fp_pscB>
 c2e:	40 f0       	brcs	.+16     	; 0xc40 <__divsf3+0x18>
 c30:	f9 d0       	rcall	.+498    	; 0xe24 <__fp_pscA>
 c32:	30 f0       	brcs	.+12     	; 0xc40 <__divsf3+0x18>
 c34:	21 f4       	brne	.+8      	; 0xc3e <__divsf3+0x16>
 c36:	5f 3f       	cpi	r21, 0xFF	; 255
 c38:	19 f0       	breq	.+6      	; 0xc40 <__divsf3+0x18>
 c3a:	eb c0       	rjmp	.+470    	; 0xe12 <__fp_inf>
 c3c:	51 11       	cpse	r21, r1
 c3e:	34 c1       	rjmp	.+616    	; 0xea8 <__fp_szero>
 c40:	ee c0       	rjmp	.+476    	; 0xe1e <__fp_nan>

00000c42 <__divsf3x>:
__divsf3x():
 c42:	0f d1       	rcall	.+542    	; 0xe62 <__fp_split3>
 c44:	98 f3       	brcs	.-26     	; 0xc2c <__divsf3+0x4>

00000c46 <__divsf3_pse>:
 c46:	99 23       	and	r25, r25
 c48:	c9 f3       	breq	.-14     	; 0xc3c <__divsf3+0x14>
 c4a:	55 23       	and	r21, r21
 c4c:	b1 f3       	breq	.-20     	; 0xc3a <__divsf3+0x12>
 c4e:	95 1b       	sub	r25, r21
 c50:	55 0b       	sbc	r21, r21
 c52:	bb 27       	eor	r27, r27
 c54:	aa 27       	eor	r26, r26
 c56:	62 17       	cp	r22, r18
 c58:	73 07       	cpc	r23, r19
 c5a:	84 07       	cpc	r24, r20
 c5c:	38 f0       	brcs	.+14     	; 0xc6c <__divsf3_pse+0x26>
 c5e:	9f 5f       	subi	r25, 0xFF	; 255
 c60:	5f 4f       	sbci	r21, 0xFF	; 255
 c62:	22 0f       	add	r18, r18
 c64:	33 1f       	adc	r19, r19
 c66:	44 1f       	adc	r20, r20
 c68:	aa 1f       	adc	r26, r26
 c6a:	a9 f3       	breq	.-22     	; 0xc56 <__divsf3_pse+0x10>
 c6c:	33 d0       	rcall	.+102    	; 0xcd4 <__divsf3_pse+0x8e>
 c6e:	0e 2e       	mov	r0, r30
 c70:	3a f0       	brmi	.+14     	; 0xc80 <__divsf3_pse+0x3a>
 c72:	e0 e8       	ldi	r30, 0x80	; 128
 c74:	30 d0       	rcall	.+96     	; 0xcd6 <__divsf3_pse+0x90>
 c76:	91 50       	subi	r25, 0x01	; 1
 c78:	50 40       	sbci	r21, 0x00	; 0
 c7a:	e6 95       	lsr	r30
 c7c:	00 1c       	adc	r0, r0
 c7e:	ca f7       	brpl	.-14     	; 0xc72 <__divsf3_pse+0x2c>
 c80:	29 d0       	rcall	.+82     	; 0xcd4 <__divsf3_pse+0x8e>
 c82:	fe 2f       	mov	r31, r30
 c84:	27 d0       	rcall	.+78     	; 0xcd4 <__divsf3_pse+0x8e>
 c86:	66 0f       	add	r22, r22
 c88:	77 1f       	adc	r23, r23
 c8a:	88 1f       	adc	r24, r24
 c8c:	bb 1f       	adc	r27, r27
 c8e:	26 17       	cp	r18, r22
 c90:	37 07       	cpc	r19, r23
 c92:	48 07       	cpc	r20, r24
 c94:	ab 07       	cpc	r26, r27
 c96:	b0 e8       	ldi	r27, 0x80	; 128
 c98:	09 f0       	breq	.+2      	; 0xc9c <__divsf3_pse+0x56>
 c9a:	bb 0b       	sbc	r27, r27
 c9c:	80 2d       	mov	r24, r0
 c9e:	bf 01       	movw	r22, r30
 ca0:	ff 27       	eor	r31, r31
 ca2:	93 58       	subi	r25, 0x83	; 131
 ca4:	5f 4f       	sbci	r21, 0xFF	; 255
 ca6:	2a f0       	brmi	.+10     	; 0xcb2 <__divsf3_pse+0x6c>
 ca8:	9e 3f       	cpi	r25, 0xFE	; 254
 caa:	51 05       	cpc	r21, r1
 cac:	68 f0       	brcs	.+26     	; 0xcc8 <__divsf3_pse+0x82>
 cae:	b1 c0       	rjmp	.+354    	; 0xe12 <__fp_inf>
 cb0:	fb c0       	rjmp	.+502    	; 0xea8 <__fp_szero>
 cb2:	5f 3f       	cpi	r21, 0xFF	; 255
 cb4:	ec f3       	brlt	.-6      	; 0xcb0 <__divsf3_pse+0x6a>
 cb6:	98 3e       	cpi	r25, 0xE8	; 232
 cb8:	dc f3       	brlt	.-10     	; 0xcb0 <__divsf3_pse+0x6a>
 cba:	86 95       	lsr	r24
 cbc:	77 95       	ror	r23
 cbe:	67 95       	ror	r22
 cc0:	b7 95       	ror	r27
 cc2:	f7 95       	ror	r31
 cc4:	9f 5f       	subi	r25, 0xFF	; 255
 cc6:	c9 f7       	brne	.-14     	; 0xcba <__divsf3_pse+0x74>
 cc8:	88 0f       	add	r24, r24
 cca:	91 1d       	adc	r25, r1
 ccc:	96 95       	lsr	r25
 cce:	87 95       	ror	r24
 cd0:	97 f9       	bld	r25, 7
 cd2:	08 95       	ret
 cd4:	e1 e0       	ldi	r30, 0x01	; 1
 cd6:	66 0f       	add	r22, r22
 cd8:	77 1f       	adc	r23, r23
 cda:	88 1f       	adc	r24, r24
 cdc:	bb 1f       	adc	r27, r27
 cde:	62 17       	cp	r22, r18
 ce0:	73 07       	cpc	r23, r19
 ce2:	84 07       	cpc	r24, r20
 ce4:	ba 07       	cpc	r27, r26
 ce6:	20 f0       	brcs	.+8      	; 0xcf0 <__divsf3_pse+0xaa>
 ce8:	62 1b       	sub	r22, r18
 cea:	73 0b       	sbc	r23, r19
 cec:	84 0b       	sbc	r24, r20
 cee:	ba 0b       	sbc	r27, r26
 cf0:	ee 1f       	adc	r30, r30
 cf2:	88 f7       	brcc	.-30     	; 0xcd6 <__divsf3_pse+0x90>
 cf4:	e0 95       	com	r30
 cf6:	08 95       	ret

00000cf8 <__fixunssfsi>:
 cf8:	bc d0       	rcall	.+376    	; 0xe72 <__fp_splitA>
 cfa:	88 f0       	brcs	.+34     	; 0xd1e <__fixunssfsi+0x26>
 cfc:	9f 57       	subi	r25, 0x7F	; 127
 cfe:	90 f0       	brcs	.+36     	; 0xd24 <__fixunssfsi+0x2c>
 d00:	b9 2f       	mov	r27, r25
 d02:	99 27       	eor	r25, r25
 d04:	b7 51       	subi	r27, 0x17	; 23
 d06:	a0 f0       	brcs	.+40     	; 0xd30 <__fixunssfsi+0x38>
 d08:	d1 f0       	breq	.+52     	; 0xd3e <__fixunssfsi+0x46>
 d0a:	66 0f       	add	r22, r22
 d0c:	77 1f       	adc	r23, r23
__fixunssfsi():
 d0e:	88 1f       	adc	r24, r24
 d10:	99 1f       	adc	r25, r25
 d12:	1a f0       	brmi	.+6      	; 0xd1a <__fixunssfsi+0x22>
 d14:	ba 95       	dec	r27
 d16:	c9 f7       	brne	.-14     	; 0xd0a <__fixunssfsi+0x12>
 d18:	12 c0       	rjmp	.+36     	; 0xd3e <__fixunssfsi+0x46>
 d1a:	b1 30       	cpi	r27, 0x01	; 1
 d1c:	81 f0       	breq	.+32     	; 0xd3e <__fixunssfsi+0x46>
 d1e:	c3 d0       	rcall	.+390    	; 0xea6 <__fp_zero>
 d20:	b1 e0       	ldi	r27, 0x01	; 1
 d22:	08 95       	ret
 d24:	c0 c0       	rjmp	.+384    	; 0xea6 <__fp_zero>
 d26:	67 2f       	mov	r22, r23
 d28:	78 2f       	mov	r23, r24
 d2a:	88 27       	eor	r24, r24
 d2c:	b8 5f       	subi	r27, 0xF8	; 248
 d2e:	39 f0       	breq	.+14     	; 0xd3e <__fixunssfsi+0x46>
 d30:	b9 3f       	cpi	r27, 0xF9	; 249
 d32:	cc f3       	brlt	.-14     	; 0xd26 <__fixunssfsi+0x2e>
 d34:	86 95       	lsr	r24
 d36:	77 95       	ror	r23
 d38:	67 95       	ror	r22
 d3a:	b3 95       	inc	r27
 d3c:	d9 f7       	brne	.-10     	; 0xd34 <__fixunssfsi+0x3c>
 d3e:	3e f4       	brtc	.+14     	; 0xd4e <__fixunssfsi+0x56>
 d40:	90 95       	com	r25
 d42:	80 95       	com	r24
 d44:	70 95       	com	r23
 d46:	61 95       	neg	r22
 d48:	7f 4f       	sbci	r23, 0xFF	; 255
 d4a:	8f 4f       	sbci	r24, 0xFF	; 255
 d4c:	9f 4f       	sbci	r25, 0xFF	; 255
 d4e:	08 95       	ret

00000d50 <__floatunsisf>:
__floatunsisf():
 d50:	e8 94       	clt
 d52:	09 c0       	rjmp	.+18     	; 0xd66 <__floatsisf+0x12>

00000d54 <__floatsisf>:
 d54:	97 fb       	bst	r25, 7
 d56:	3e f4       	brtc	.+14     	; 0xd66 <__floatsisf+0x12>
 d58:	90 95       	com	r25
 d5a:	80 95       	com	r24
 d5c:	70 95       	com	r23
 d5e:	61 95       	neg	r22
 d60:	7f 4f       	sbci	r23, 0xFF	; 255
 d62:	8f 4f       	sbci	r24, 0xFF	; 255
 d64:	9f 4f       	sbci	r25, 0xFF	; 255
 d66:	99 23       	and	r25, r25
 d68:	a9 f0       	breq	.+42     	; 0xd94 <__floatsisf+0x40>
 d6a:	f9 2f       	mov	r31, r25
 d6c:	96 e9       	ldi	r25, 0x96	; 150
 d6e:	bb 27       	eor	r27, r27
 d70:	93 95       	inc	r25
 d72:	f6 95       	lsr	r31
 d74:	87 95       	ror	r24
 d76:	77 95       	ror	r23
 d78:	67 95       	ror	r22
 d7a:	b7 95       	ror	r27
 d7c:	f1 11       	cpse	r31, r1
 d7e:	f8 cf       	rjmp	.-16     	; 0xd70 <__floatsisf+0x1c>
 d80:	fa f4       	brpl	.+62     	; 0xdc0 <__floatsisf+0x6c>
 d82:	bb 0f       	add	r27, r27
 d84:	11 f4       	brne	.+4      	; 0xd8a <__floatsisf+0x36>
 d86:	60 ff       	sbrs	r22, 0
 d88:	1b c0       	rjmp	.+54     	; 0xdc0 <__floatsisf+0x6c>
 d8a:	6f 5f       	subi	r22, 0xFF	; 255
 d8c:	7f 4f       	sbci	r23, 0xFF	; 255
 d8e:	8f 4f       	sbci	r24, 0xFF	; 255
 d90:	9f 4f       	sbci	r25, 0xFF	; 255
 d92:	16 c0       	rjmp	.+44     	; 0xdc0 <__floatsisf+0x6c>
 d94:	88 23       	and	r24, r24
 d96:	11 f0       	breq	.+4      	; 0xd9c <__floatsisf+0x48>
 d98:	96 e9       	ldi	r25, 0x96	; 150
 d9a:	11 c0       	rjmp	.+34     	; 0xdbe <__floatsisf+0x6a>
 d9c:	77 23       	and	r23, r23
 d9e:	21 f0       	breq	.+8      	; 0xda8 <__floatsisf+0x54>
 da0:	9e e8       	ldi	r25, 0x8E	; 142
 da2:	87 2f       	mov	r24, r23
 da4:	76 2f       	mov	r23, r22
 da6:	05 c0       	rjmp	.+10     	; 0xdb2 <__floatsisf+0x5e>
 da8:	66 23       	and	r22, r22
 daa:	71 f0       	breq	.+28     	; 0xdc8 <__floatsisf+0x74>
 dac:	96 e8       	ldi	r25, 0x86	; 134
 dae:	86 2f       	mov	r24, r22
 db0:	70 e0       	ldi	r23, 0x00	; 0
 db2:	60 e0       	ldi	r22, 0x00	; 0
 db4:	2a f0       	brmi	.+10     	; 0xdc0 <__floatsisf+0x6c>
 db6:	9a 95       	dec	r25
 db8:	66 0f       	add	r22, r22
 dba:	77 1f       	adc	r23, r23
 dbc:	88 1f       	adc	r24, r24
 dbe:	da f7       	brpl	.-10     	; 0xdb6 <__floatsisf+0x62>
 dc0:	88 0f       	add	r24, r24
 dc2:	96 95       	lsr	r25
 dc4:	87 95       	ror	r24
 dc6:	97 f9       	bld	r25, 7
 dc8:	08 95       	ret

00000dca <__fp_cmp>:
__fp_cmp():
 dca:	99 0f       	add	r25, r25
 dcc:	00 08       	sbc	r0, r0
 dce:	55 0f       	add	r21, r21
 dd0:	aa 0b       	sbc	r26, r26
 dd2:	e0 e8       	ldi	r30, 0x80	; 128
 dd4:	fe ef       	ldi	r31, 0xFE	; 254
 dd6:	16 16       	cp	r1, r22
 dd8:	17 06       	cpc	r1, r23
 dda:	e8 07       	cpc	r30, r24
 ddc:	f9 07       	cpc	r31, r25
 dde:	c0 f0       	brcs	.+48     	; 0xe10 <__fp_cmp+0x46>
 de0:	12 16       	cp	r1, r18
 de2:	13 06       	cpc	r1, r19
 de4:	e4 07       	cpc	r30, r20
 de6:	f5 07       	cpc	r31, r21
 de8:	98 f0       	brcs	.+38     	; 0xe10 <__fp_cmp+0x46>
 dea:	62 1b       	sub	r22, r18
 dec:	73 0b       	sbc	r23, r19
 dee:	84 0b       	sbc	r24, r20
 df0:	95 0b       	sbc	r25, r21
 df2:	39 f4       	brne	.+14     	; 0xe02 <__fp_cmp+0x38>
 df4:	0a 26       	eor	r0, r26
 df6:	61 f0       	breq	.+24     	; 0xe10 <__fp_cmp+0x46>
 df8:	23 2b       	or	r18, r19
 dfa:	24 2b       	or	r18, r20
 dfc:	25 2b       	or	r18, r21
 dfe:	21 f4       	brne	.+8      	; 0xe08 <__fp_cmp+0x3e>
 e00:	08 95       	ret
 e02:	0a 26       	eor	r0, r26
 e04:	09 f4       	brne	.+2      	; 0xe08 <__fp_cmp+0x3e>
 e06:	a1 40       	sbci	r26, 0x01	; 1
 e08:	a6 95       	lsr	r26
 e0a:	8f ef       	ldi	r24, 0xFF	; 255
 e0c:	81 1d       	adc	r24, r1
 e0e:	81 1d       	adc	r24, r1
 e10:	08 95       	ret

00000e12 <__fp_inf>:
__fp_inf():
 e12:	97 f9       	bld	r25, 7
 e14:	9f 67       	ori	r25, 0x7F	; 127
 e16:	80 e8       	ldi	r24, 0x80	; 128
 e18:	70 e0       	ldi	r23, 0x00	; 0
 e1a:	60 e0       	ldi	r22, 0x00	; 0
 e1c:	08 95       	ret

00000e1e <__fp_nan>:
__fp_nan():
 e1e:	9f ef       	ldi	r25, 0xFF	; 255
 e20:	80 ec       	ldi	r24, 0xC0	; 192
 e22:	08 95       	ret

00000e24 <__fp_pscA>:
__fp_pscA():
 e24:	00 24       	eor	r0, r0
 e26:	0a 94       	dec	r0
 e28:	16 16       	cp	r1, r22
 e2a:	17 06       	cpc	r1, r23
 e2c:	18 06       	cpc	r1, r24
 e2e:	09 06       	cpc	r0, r25
 e30:	08 95       	ret

00000e32 <__fp_pscB>:
__fp_pscB():
 e32:	00 24       	eor	r0, r0
 e34:	0a 94       	dec	r0
 e36:	12 16       	cp	r1, r18
 e38:	13 06       	cpc	r1, r19
 e3a:	14 06       	cpc	r1, r20
 e3c:	05 06       	cpc	r0, r21
 e3e:	08 95       	ret

00000e40 <__fp_round>:
__fp_round():
 e40:	09 2e       	mov	r0, r25
 e42:	03 94       	inc	r0
 e44:	00 0c       	add	r0, r0
 e46:	11 f4       	brne	.+4      	; 0xe4c <__fp_round+0xc>
 e48:	88 23       	and	r24, r24
 e4a:	52 f0       	brmi	.+20     	; 0xe60 <__fp_round+0x20>
 e4c:	bb 0f       	add	r27, r27
 e4e:	40 f4       	brcc	.+16     	; 0xe60 <__fp_round+0x20>
 e50:	bf 2b       	or	r27, r31
 e52:	11 f4       	brne	.+4      	; 0xe58 <__fp_round+0x18>
 e54:	60 ff       	sbrs	r22, 0
 e56:	04 c0       	rjmp	.+8      	; 0xe60 <__fp_round+0x20>
 e58:	6f 5f       	subi	r22, 0xFF	; 255
 e5a:	7f 4f       	sbci	r23, 0xFF	; 255
 e5c:	8f 4f       	sbci	r24, 0xFF	; 255
 e5e:	9f 4f       	sbci	r25, 0xFF	; 255
 e60:	08 95       	ret

00000e62 <__fp_split3>:
__fp_split3():
 e62:	57 fd       	sbrc	r21, 7
 e64:	90 58       	subi	r25, 0x80	; 128
 e66:	44 0f       	add	r20, r20
 e68:	55 1f       	adc	r21, r21
 e6a:	59 f0       	breq	.+22     	; 0xe82 <__fp_splitA+0x10>
 e6c:	5f 3f       	cpi	r21, 0xFF	; 255
 e6e:	71 f0       	breq	.+28     	; 0xe8c <__fp_splitA+0x1a>
 e70:	47 95       	ror	r20

00000e72 <__fp_splitA>:
 e72:	88 0f       	add	r24, r24
 e74:	97 fb       	bst	r25, 7
 e76:	99 1f       	adc	r25, r25
 e78:	61 f0       	breq	.+24     	; 0xe92 <__fp_splitA+0x20>
 e7a:	9f 3f       	cpi	r25, 0xFF	; 255
 e7c:	79 f0       	breq	.+30     	; 0xe9c <__fp_splitA+0x2a>
 e7e:	87 95       	ror	r24
 e80:	08 95       	ret
 e82:	12 16       	cp	r1, r18
 e84:	13 06       	cpc	r1, r19
 e86:	14 06       	cpc	r1, r20
 e88:	55 1f       	adc	r21, r21
 e8a:	f2 cf       	rjmp	.-28     	; 0xe70 <__fp_split3+0xe>
 e8c:	46 95       	lsr	r20
 e8e:	f1 df       	rcall	.-30     	; 0xe72 <__fp_splitA>
 e90:	08 c0       	rjmp	.+16     	; 0xea2 <__fp_splitA+0x30>
 e92:	16 16       	cp	r1, r22
 e94:	17 06       	cpc	r1, r23
 e96:	18 06       	cpc	r1, r24
 e98:	99 1f       	adc	r25, r25
 e9a:	f1 cf       	rjmp	.-30     	; 0xe7e <__fp_splitA+0xc>
 e9c:	86 95       	lsr	r24
 e9e:	71 05       	cpc	r23, r1
 ea0:	61 05       	cpc	r22, r1
 ea2:	08 94       	sec
 ea4:	08 95       	ret

00000ea6 <__fp_zero>:
__fp_zero():
 ea6:	e8 94       	clt

00000ea8 <__fp_szero>:
 ea8:	bb 27       	eor	r27, r27
 eaa:	66 27       	eor	r22, r22
 eac:	77 27       	eor	r23, r23
 eae:	cb 01       	movw	r24, r22
 eb0:	97 f9       	bld	r25, 7
 eb2:	08 95       	ret

00000eb4 <__gesf2>:
__gesf2():
 eb4:	8a df       	rcall	.-236    	; 0xdca <__fp_cmp>
 eb6:	08 f4       	brcc	.+2      	; 0xeba <__gesf2+0x6>
 eb8:	8f ef       	ldi	r24, 0xFF	; 255
 eba:	08 95       	ret

00000ebc <__mulsf3>:
__mulsf3():
 ebc:	0a d0       	rcall	.+20     	; 0xed2 <__mulsf3x>
 ebe:	c0 cf       	rjmp	.-128    	; 0xe40 <__fp_round>
 ec0:	b1 df       	rcall	.-158    	; 0xe24 <__fp_pscA>
 ec2:	28 f0       	brcs	.+10     	; 0xece <__mulsf3+0x12>
 ec4:	b6 df       	rcall	.-148    	; 0xe32 <__fp_pscB>
 ec6:	18 f0       	brcs	.+6      	; 0xece <__mulsf3+0x12>
 ec8:	95 23       	and	r25, r21
 eca:	09 f0       	breq	.+2      	; 0xece <__mulsf3+0x12>
 ecc:	a2 cf       	rjmp	.-188    	; 0xe12 <__fp_inf>
 ece:	a7 cf       	rjmp	.-178    	; 0xe1e <__fp_nan>
 ed0:	eb cf       	rjmp	.-42     	; 0xea8 <__fp_szero>

00000ed2 <__mulsf3x>:
__mulsf3x():
 ed2:	c7 df       	rcall	.-114    	; 0xe62 <__fp_split3>
 ed4:	a8 f3       	brcs	.-22     	; 0xec0 <__mulsf3+0x4>

00000ed6 <__mulsf3_pse>:
 ed6:	99 23       	and	r25, r25
 ed8:	d9 f3       	breq	.-10     	; 0xed0 <__mulsf3+0x14>
 eda:	55 23       	and	r21, r21
 edc:	c9 f3       	breq	.-14     	; 0xed0 <__mulsf3+0x14>
 ede:	95 0f       	add	r25, r21
 ee0:	50 e0       	ldi	r21, 0x00	; 0
 ee2:	55 1f       	adc	r21, r21
 ee4:	aa 27       	eor	r26, r26
 ee6:	ee 27       	eor	r30, r30
 ee8:	ff 27       	eor	r31, r31
 eea:	bb 27       	eor	r27, r27
 eec:	00 24       	eor	r0, r0
 eee:	08 94       	sec
 ef0:	67 95       	ror	r22
 ef2:	20 f4       	brcc	.+8      	; 0xefc <__mulsf3_pse+0x26>
 ef4:	e2 0f       	add	r30, r18
 ef6:	f3 1f       	adc	r31, r19
 ef8:	b4 1f       	adc	r27, r20
 efa:	0a 1e       	adc	r0, r26
 efc:	22 0f       	add	r18, r18
 efe:	33 1f       	adc	r19, r19
 f00:	44 1f       	adc	r20, r20
 f02:	aa 1f       	adc	r26, r26
 f04:	66 95       	lsr	r22
 f06:	a9 f7       	brne	.-22     	; 0xef2 <__mulsf3_pse+0x1c>
 f08:	77 95       	ror	r23
 f0a:	30 f4       	brcc	.+12     	; 0xf18 <__mulsf3_pse+0x42>
 f0c:	f3 0f       	add	r31, r19
 f0e:	b4 1f       	adc	r27, r20
 f10:	0a 1e       	adc	r0, r26
 f12:	12 1e       	adc	r1, r18
 f14:	08 f4       	brcc	.+2      	; 0xf18 <__mulsf3_pse+0x42>
 f16:	63 95       	inc	r22
 f18:	33 0f       	add	r19, r19
 f1a:	44 1f       	adc	r20, r20
 f1c:	aa 1f       	adc	r26, r26
 f1e:	22 1f       	adc	r18, r18
 f20:	76 95       	lsr	r23
 f22:	99 f7       	brne	.-26     	; 0xf0a <__mulsf3_pse+0x34>
 f24:	87 95       	ror	r24
 f26:	20 f4       	brcc	.+8      	; 0xf30 <__mulsf3_pse+0x5a>
 f28:	b4 0f       	add	r27, r20
 f2a:	0a 1e       	adc	r0, r26
 f2c:	12 1e       	adc	r1, r18
 f2e:	63 1f       	adc	r22, r19
 f30:	44 0f       	add	r20, r20
 f32:	aa 1f       	adc	r26, r26
 f34:	22 1f       	adc	r18, r18
 f36:	33 1f       	adc	r19, r19
 f38:	86 95       	lsr	r24
 f3a:	a9 f7       	brne	.-22     	; 0xf26 <__mulsf3_pse+0x50>
 f3c:	86 2f       	mov	r24, r22
 f3e:	71 2d       	mov	r23, r1
 f40:	60 2d       	mov	r22, r0
 f42:	11 24       	eor	r1, r1
 f44:	9f 57       	subi	r25, 0x7F	; 127
 f46:	50 40       	sbci	r21, 0x00	; 0
 f48:	8a f0       	brmi	.+34     	; 0xf6c <__mulsf3_pse+0x96>
 f4a:	e1 f0       	breq	.+56     	; 0xf84 <__mulsf3_pse+0xae>
 f4c:	88 23       	and	r24, r24
 f4e:	4a f0       	brmi	.+18     	; 0xf62 <__mulsf3_pse+0x8c>
 f50:	ee 0f       	add	r30, r30
 f52:	ff 1f       	adc	r31, r31
 f54:	bb 1f       	adc	r27, r27
 f56:	66 1f       	adc	r22, r22
 f58:	77 1f       	adc	r23, r23
 f5a:	88 1f       	adc	r24, r24
 f5c:	91 50       	subi	r25, 0x01	; 1
 f5e:	50 40       	sbci	r21, 0x00	; 0
 f60:	a9 f7       	brne	.-22     	; 0xf4c <__mulsf3_pse+0x76>
 f62:	9e 3f       	cpi	r25, 0xFE	; 254
 f64:	51 05       	cpc	r21, r1
 f66:	70 f0       	brcs	.+28     	; 0xf84 <__mulsf3_pse+0xae>
 f68:	54 cf       	rjmp	.-344    	; 0xe12 <__fp_inf>
 f6a:	9e cf       	rjmp	.-196    	; 0xea8 <__fp_szero>
 f6c:	5f 3f       	cpi	r21, 0xFF	; 255
 f6e:	ec f3       	brlt	.-6      	; 0xf6a <__mulsf3_pse+0x94>
 f70:	98 3e       	cpi	r25, 0xE8	; 232
 f72:	dc f3       	brlt	.-10     	; 0xf6a <__mulsf3_pse+0x94>
 f74:	86 95       	lsr	r24
 f76:	77 95       	ror	r23
 f78:	67 95       	ror	r22
 f7a:	b7 95       	ror	r27
 f7c:	f7 95       	ror	r31
 f7e:	e7 95       	ror	r30
 f80:	9f 5f       	subi	r25, 0xFF	; 255
 f82:	c1 f7       	brne	.-16     	; 0xf74 <__mulsf3_pse+0x9e>
 f84:	fe 2b       	or	r31, r30
 f86:	88 0f       	add	r24, r24
 f88:	91 1d       	adc	r25, r1
 f8a:	96 95       	lsr	r25
 f8c:	87 95       	ror	r24
 f8e:	97 f9       	bld	r25, 7
 f90:	08 95       	ret

00000f92 <__mulhi3>:
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:312
 f92:	00 24       	eor	r0, r0
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:313
 f94:	55 27       	eor	r21, r21
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:314
 f96:	04 c0       	rjmp	.+8      	; 0xfa0 <__mulhi3+0xe>
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:317
 f98:	08 0e       	add	r0, r24
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:318
 f9a:	59 1f       	adc	r21, r25
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:320
 f9c:	88 0f       	add	r24, r24
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:321
 f9e:	99 1f       	adc	r25, r25
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:324
 fa0:	00 97       	sbiw	r24, 0x00	; 0
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:325
 fa2:	29 f0       	breq	.+10     	; 0xfae <__mulhi3+0x1c>
__mulhi3():
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:328
 fa4:	76 95       	lsr	r23
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:329
 fa6:	67 95       	ror	r22
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:331
 fa8:	b8 f3       	brcs	.-18     	; 0xf98 <__mulhi3+0x6>
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:335
 faa:	71 05       	cpc	r23, r1
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:337
 fac:	b9 f7       	brne	.-18     	; 0xf9c <__mulhi3+0xa>
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:340
 fae:	80 2d       	mov	r24, r0
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:341
 fb0:	95 2f       	mov	r25, r21
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:342
 fb2:	08 95       	ret

00000fb4 <__udivmodhi4>:
__udivmodhi4():
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1408
 fb4:	aa 1b       	sub	r26, r26
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1409
 fb6:	bb 1b       	sub	r27, r27
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1410
 fb8:	51 e1       	ldi	r21, 0x11	; 17
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1411
 fba:	07 c0       	rjmp	.+14     	; 0xfca <__udivmodhi4_ep>

00000fbc <__udivmodhi4_loop>:
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1413
 fbc:	aa 1f       	adc	r26, r26
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1414
 fbe:	bb 1f       	adc	r27, r27
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1415
 fc0:	a6 17       	cp	r26, r22
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1416
 fc2:	b7 07       	cpc	r27, r23
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1417
 fc4:	10 f0       	brcs	.+4      	; 0xfca <__udivmodhi4_ep>
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1418
 fc6:	a6 1b       	sub	r26, r22
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1419
 fc8:	b7 0b       	sbc	r27, r23

00000fca <__udivmodhi4_ep>:
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1421
 fca:	88 1f       	adc	r24, r24
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1422
 fcc:	99 1f       	adc	r25, r25
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1423
 fce:	5a 95       	dec	r21
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1424
 fd0:	a9 f7       	brne	.-22     	; 0xfbc <__udivmodhi4_loop>
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1425
 fd2:	80 95       	com	r24
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1426
 fd4:	90 95       	com	r25
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1428
 fd6:	bc 01       	movw	r22, r24
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1430
 fd8:	cd 01       	movw	r24, r26
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1432
 fda:	08 95       	ret

00000fdc <__tablejump2__>:
__tablejump2__():
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2296
 fdc:	ee 0f       	add	r30, r30
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2297
 fde:	ff 1f       	adc	r31, r31
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2328
 fe0:	05 90       	lpm	r0, Z+
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2329
 fe2:	f4 91       	lpm	r31, Z
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2330
 fe4:	e0 2d       	mov	r30, r0
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2331
 fe6:	09 94       	ijmp

00000fe8 <_exit>:
exit():
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2278
 fe8:	f8 94       	cli

00000fea <__stop_program>:
__stop_program():
/Users/jenkins/jenkins/workspace/avr-gcc-staging/label/mac-mini/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2280
 fea:	ff cf       	rjmp	.-2      	; 0xfea <__stop_program>
